<HTML>
<HEAD>
<TITLE>Spreadsheet::WriteExcel - Write to a cross-platform Excel binary file.</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<style type="text/css">



   <!--

   pre  {
        font-family : courier new, sans-serif;
        font-size : 10pt;
        color : #0066cc;
   }

   CODE  {
        font-family : courier new, sans-serif;
        font-size : 10pt;
        color : #0066cc;
   }


   -->
</style>


<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A></LI>
	<LI><A HREF="#VERSION">VERSION</A></LI>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A></LI>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A></LI>
	<LI><A HREF="#QUICK_START">QUICK START</A></LI>
	<LI><A HREF="#WORKBOOK_METHODS">WORKBOOK METHODS</A></LI>
	<UL>

        <code>
		<LI><A HREF="#new_">new()</A></LI>
		<LI><A HREF="#add_worksheet_sheetname_utf_1">add_worksheet($sheetname, $utf_16_be)</A></LI>
		<LI><A HREF="#add_format_properties_">add_format(%properties)</A></LI>
		<LI><A HREF="#add_chart_ext_chart_data_char">add_chart_ext($chart_data, $chartname)</A></LI>
		<LI><A HREF="#close_">close()</A></LI>
		<LI><A HREF="#compatibility_mode_">compatibility_mode()</A></LI>
		<LI><A HREF="#set_tempdir_">set_tempdir()</A></LI>
		<LI><A HREF="#set_custom_color_index_red_">set_custom_color($index, $red, $green, $blue)</A></LI>
		<LI><A HREF="#sheets_0_1_">sheets(0, 1, ...)</A></LI>
		<LI><A HREF="#set_1904_">set_1904()</A></LI>
		<LI><A HREF="#set_codepage_codepage_">set_codepage($codepage)</A></LI>
        </code>
	</UL>

	<LI><A HREF="#WORKSHEET_METHODS">WORKSHEET METHODS</A></LI>
	<UL>

        <code>
		<LI><A HREF="#Cell_notation">Cell notation</A></LI>
		<LI><A HREF="#write_row_column_token_fo">write($row, $column, $token, $format)</A></LI>
		<LI><A HREF="#write_number_row_column_num">write_number($row, $column, $number, $format)</A></LI>
		<LI><A HREF="#write_string_row_column_str">write_string($row, $column, $string, $format)</A></LI>
		<LI><A HREF="#write_utf16be_string_row_colu">write_utf16be_string($row, $column, $string, $format)</A></LI>
		<LI><A HREF="#write_utf16le_string_row_colu">write_utf16le_string($row, $column, $string, $format)</A></LI>
		<LI><A HREF="#keep_leading_zeros_">keep_leading_zeros()</A></LI>
		<LI><A HREF="#write_blank_row_column_form">write_blank($row, $column, $format)</A></LI>
		<LI><A HREF="#write_row_row_column_array_">write_row($row, $column, $array_ref, $format)</A></LI>
		<LI><A HREF="#write_col_row_column_array_">write_col($row, $column, $array_ref, $format)</A></LI>
		<LI><A HREF="#write_date_time_row_col_dat">write_date_time($row, $col, $date_string, $format)</A></LI>
		<LI><A HREF="#write_url_row_col_url_lab">write_url($row, $col, $url, $label, $format)</A></LI>
		<LI><A HREF="#write_url_range_row1_col1_r">write_url_range($row1, $col1, $row2, $col2, $url, $string, $format)</A></LI>
		<LI><A HREF="#write_formula_row_column_fo">write_formula($row, $column, $formula, $format, $value)</A></LI>
		<LI><A HREF="#store_formula_formula_">store_formula($formula)</A></LI>
		<LI><A HREF="#repeat_formula_row_col_form">repeat_formula($row, $col, $formula, $format, ($pattern =&gt; $replace, ...))</A></LI>
		<LI><A HREF="#write_comment_row_column_st">write_comment($row, $column, $string, ...)</A></LI>
		<LI><A HREF="#show_comments_">show_comments()</A></LI>
		<LI><A HREF="#add_write_handler_re_code_ref">add_write_handler($re, $code_ref)</A></LI>
		<LI><A HREF="#insert_image_row_col_filena">insert_image($row, $col, $filename, $x, $y, $scale_x, $scale_y)</A></LI>
		<LI><A HREF="#embed_chart_row_col_filenam">embed_chart($row, $col, $filename, $x, $y, $scale_x, $scale_y)</A></LI>
		<LI><A HREF="#get_name_">get_name()</A></LI>
		<LI><A HREF="#activate_">activate()</A></LI>
		<LI><A HREF="#select_">select()</A></LI>
		<LI><A HREF="#hide_">hide()</A></LI>
		<LI><A HREF="#set_first_sheet_">set_first_sheet()</A></LI>
		<LI><A HREF="#protect_password_">protect($password)</A></LI>
		<LI><A HREF="#set_selection_first_row_first">set_selection($first_row, $first_col, $last_row, $last_col)</A></LI>
		<LI><A HREF="#set_row_row_height_format_">set_row($row, $height, $format, $hidden, $level, $collapsed)</A></LI>
		<LI><A HREF="#set_column_first_col_last_col">set_column($first_col, $last_col, $width, $format, $hidden, $level, $collapsed)</A></LI>
		<LI><A HREF="#outline_settings_visible_symb">outline_settings($visible, $symbols_below, $symbols_right, $auto_style)</A></LI>
		<LI><A HREF="#freeze_panes_row_col_top_ro">freeze_panes($row, $col, $top_row, $left_col)</A></LI>
		<LI><A HREF="#split_panes_y_x_top_row_l">split_panes($y, $x, $top_row, $left_col)</A></LI>
		<LI><A HREF="#merge_range_first_row_first_c">merge_range($first_row, $first_col, $last_row, $last_col, $token, $format, $utf_16_be)</A></LI>
		<LI><A HREF="#set_zoom_scale_">set_zoom($scale)</A></LI>
		<LI><A HREF="#right_to_left_">right_to_left()</A></LI>
		<LI><A HREF="#hide_zero_">hide_zero()</A></LI>
		<LI><A HREF="#set_tab_color_">set_tab_color()</A></LI>
        </code>
	</UL>

	<LI><A HREF="#PAGE_SET_UP_METHODS">PAGE SET-UP METHODS</A></LI>
	<UL>

        <code>
		<LI><A HREF="#set_landscape_">set_landscape()</A></LI>
		<LI><A HREF="#set_portrait_">set_portrait()</A></LI>
		<LI><A HREF="#set_page_view_">set_page_view()</A></LI>
		<LI><A HREF="#set_paper_index_">set_paper($index)</A></LI>
		<LI><A HREF="#center_horizontally_">center_horizontally()</A></LI>
		<LI><A HREF="#center_vertically_">center_vertically()</A></LI>
		<LI><A HREF="#set_margins_inches_">set_margins($inches)</A></LI>
		<LI><A HREF="#set_header_string_margin_">set_header($string, $margin)</A></LI>
		<LI><A HREF="#set_footer_">set_footer()</A></LI>
		<LI><A HREF="#repeat_rows_first_row_last_ro">repeat_rows($first_row, $last_row)</A></LI>
		<LI><A HREF="#repeat_columns_first_col_last">repeat_columns($first_col, $last_col)</A></LI>
		<LI><A HREF="#hide_gridlines_option_">hide_gridlines($option)</A></LI>
		<LI><A HREF="#print_row_col_headers_">print_row_col_headers()</A></LI>
		<LI><A HREF="#print_area_first_row_first_co">print_area($first_row, $first_col, $last_row, $last_col)</A></LI>
		<LI><A HREF="#print_across_">print_across()</A></LI>
		<LI><A HREF="#fit_to_pages_width_height_">fit_to_pages($width, $height)</A></LI>
		<LI><A HREF="#set_start_page_start_page_">set_start_page($start_page)</A></LI>
		<LI><A HREF="#set_print_scale_scale_">set_print_scale($scale)</A></LI>
		<LI><A HREF="#set_h_pagebreaks_breaks_">set_h_pagebreaks(@breaks)</A></LI>
		<LI><A HREF="#set_v_pagebreaks_breaks_">set_v_pagebreaks(@breaks)</A></LI>
        </code>
	</UL>

	<LI><A HREF="#CELL_FORMATTING">CELL FORMATTING</A></LI>
	<UL>

		<LI><A HREF="#Creating_and_using_a_Format_obje">Creating and using a Format object</A></LI>
		<LI><A HREF="#Format_methods_and_Format_proper">Format methods and Format properties</A></LI>
		<LI><A HREF="#Working_with_formats">Working with formats</A></LI>
	</UL>

	<LI><A HREF="#FORMAT_METHODS">FORMAT METHODS</A></LI>
	<UL>

        <code>
		<LI><A HREF="#set_properties_properties_">set_properties(%properties)</A></LI>
		<LI><A HREF="#set_font_fontname_">set_font($fontname)</A></LI>
		<LI><A HREF="#set_size_">set_size()</A></LI>
		<LI><A HREF="#set_color_">set_color()</A></LI>
		<LI><A HREF="#set_bold_">set_bold()</A></LI>
		<LI><A HREF="#set_italic_">set_italic()</A></LI>
		<LI><A HREF="#set_underline_">set_underline()</A></LI>
		<LI><A HREF="#set_font_strikeout_">set_font_strikeout()</A></LI>
		<LI><A HREF="#set_font_script_">set_font_script()</A></LI>
		<LI><A HREF="#set_font_outline_">set_font_outline()</A></LI>
		<LI><A HREF="#set_font_shadow_">set_font_shadow()</A></LI>
		<LI><A HREF="#set_num_format_">set_num_format()</A></LI>
		<LI><A HREF="#set_locked_">set_locked()</A></LI>
		<LI><A HREF="#set_hidden_">set_hidden()</A></LI>
		<LI><A HREF="#set_align_">set_align()</A></LI>
		<LI><A HREF="#set_center_across_">set_center_across()</A></LI>
		<LI><A HREF="#set_text_wrap_">set_text_wrap()</A></LI>
		<LI><A HREF="#set_rotation_">set_rotation()</A></LI>
		<LI><A HREF="#set_indent_">set_indent()</A></LI>
		<LI><A HREF="#set_shrink_">set_shrink()</A></LI>
		<LI><A HREF="#set_text_justlast_">set_text_justlast()</A></LI>
		<LI><A HREF="#set_pattern_">set_pattern()</A></LI>
		<LI><A HREF="#set_bg_color_">set_bg_color()</A></LI>
		<LI><A HREF="#set_fg_color_">set_fg_color()</A></LI>
		<LI><A HREF="#set_border_">set_border()</A></LI>
		<LI><A HREF="#set_border_color_">set_border_color()</A></LI>
		<LI><A HREF="#copy_format_">copy($format)</A></LI>
        </code>
	</UL>

	<LI><A HREF="#UNICODE_IN_EXCEL">UNICODE IN EXCEL</A></LI>
	<LI><A HREF="#COLOURS_IN_EXCEL">COLOURS IN EXCEL</A></LI>
	<LI><A HREF="#DATES_AND_TIME_IN_EXCEL">DATES AND TIME IN EXCEL</A></LI>
	<UL>

		<LI><A HREF="#An_Excel_date_time_is_a_number_p">An Excel date/time is a number plus a format</A></LI>
		<LI><A HREF="#Spreadsheet_WriteExcel_doesn_t_">Spreadsheet::WriteExcel doesn't automatically convert date/time strings</A></LI>
		<LI><A HREF="#Converting_dates_and_times_to_an">Converting dates and times to an Excel date or time</A></LI>
	</UL>

	<LI><A HREF="#OUTLINES_AND_GROUPING_IN_EXCEL">OUTLINES AND GROUPING IN EXCEL</A></LI>
	<LI><A HREF="#FORMULAS_AND_FUNCTIONS_IN_EXCEL">FORMULAS AND FUNCTIONS IN EXCEL</A></LI>
	<UL>

		<LI><A HREF="#Caveats">Caveats</A></LI>
		<LI><A HREF="#Introduction">Introduction</A></LI>
		<LI><A HREF="#Improving_performance_when_worki">Improving performance when working with formulas</A></LI>
	</UL>

	<LI><A HREF="#EXAMPLES">EXAMPLES</A></LI>
	<UL>

        <code>
		<LI><A HREF="#Example_1">Example 1</A></LI>
		<LI><A HREF="#Example_2">Example 2</A></LI>
		<LI><A HREF="#Example_3">Example 3</A></LI>
		<LI><A HREF="#Example_4">Example 4</A></LI>
		<LI><A HREF="#Example_5">Example 5</A></LI>
		<LI><A HREF="#Additional_Examples">Additional Examples</A></LI>
        </code>
	</UL>

	<LI><A HREF="#LIMITATIONS">LIMITATIONS</A></LI>
	<LI><A HREF="#DOWNLOADING">DOWNLOADING</A></LI>
	<LI><A HREF="#REQUIREMENTS">REQUIREMENTS</A></LI>
	<LI><A HREF="#INSTALLATION">INSTALLATION</A></LI>
	<LI><A HREF="#PORTABILITY">PORTABILITY</A></LI>
	<LI><A HREF="#DIAGNOSTICS">DIAGNOSTICS</A></LI>
	<LI><A HREF="#THE_EXCEL_BINARY_FORMAT">THE EXCEL BINARY FORMAT</A></LI>
	<LI><A HREF="#WRITING_EXCEL_FILES">WRITING EXCEL FILES</A></LI>
	<LI><A HREF="#READING_EXCEL_FILES">READING EXCEL FILES</A></LI>
	<LI><A HREF="#MODIFYING_AND_REWRITING_EXCEL_FI">MODIFYING AND REWRITING EXCEL FILES</A></LI>
	<LI><A HREF="#Warning_about_XML_Parser_and_pe">Warning about XML::Parser and perl 5.6</A></LI>
	<LI><A HREF="#Warning_about_Office_Service_Pac">Warning about Office Service Pack 3</A></LI>
	<LI><A HREF="#BUGS">BUGS</A></LI>
	<LI><A HREF="#TO_DO">TO DO</A></LI>
	<LI><A HREF="#MAILING_LIST">MAILING LIST</A></LI>
	<LI><A HREF="#DONATIONS">DONATIONS</A></LI>
	<LI><A HREF="#SEE_ALSO">SEE ALSO</A></LI>
	<LI><A HREF="#ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</A></LI>
	<LI><A HREF="#DISCLAIMER_OF_WARRANTY">DISCLAIMER OF WARRANTY</A></LI>
	<LI><A HREF="#LICENSE">LICENSE</A></LI>
	<LI><A HREF="#AUTHOR">AUTHOR</A></LI>
	<LI><A HREF="#COPYRIGHT">COPYRIGHT</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
Spreadsheet::WriteExcel - Write to a cross-platform Excel binary file.

</P>
<P>
<HR>
<H1><A NAME="VERSION">VERSION</A></H1>
<P>
This document refers to version 2.22 of Spreadsheet::WriteExcel, released
July 19, 2008.

</P>
<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
To write a string, a formatted string, a number and a formula to the first
worksheet in an Excel workbook called perl.xls:

</P>
<P>
<PRE>
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    # Create a new Excel workbook
    my $workbook = Spreadsheet::WriteExcel-&gt;new('perl.xls');
</PRE>
</P>
<P>
<PRE>
    # Add a worksheet
    $worksheet = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    #  Add and define a format
    $format = $workbook-&gt;add_format(); # Add a format
    $format-&gt;set_bold();
    $format-&gt;set_color('red');
    $format-&gt;set_align('center');
</PRE>
</P>
<P>
<PRE>
    # Write a formatted and unformatted string, row and column notation.
    $col = $row = 0;
    $worksheet-&gt;write($row, $col, 'Hi Excel!', $format);
    $worksheet-&gt;write(1,    $col, 'Hi Excel!');
</PRE>
</P>
<P>
<PRE>
    # Write a number and a formula using A1 notation
    $worksheet-&gt;write('A3', 1.2345);
    $worksheet-&gt;write('A4', '=SIN(PI()/4)');
</PRE>
</P>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
The Spreadsheet::WriteExcel module can be used to create a cross-platform
Excel binary file. Multiple worksheets can be added to a workbook and
formatting can be applied to cells. Text, numbers, formulas, hyperlinks and
images can be written to the cells.

</P>
<P>
The Excel file produced by this module is compatible with 97, 2000, 2002
and 2003.

</P>
<P>
The module will work on the majority of Windows, UNIX and Macintosh
platforms. Generated files are also compatible with the Linux/UNIX
spreadsheet applications Gnumeric and OpenOffice.org.

</P>
<P>
This module cannot be used to write to an existing Excel file (See <A HREF="#MODIFYING_AND_REWRITING_EXCEL_FI">MODIFYING AND REWRITING EXCEL FILES</A>).

</P>
<P>
<HR>
<H1><A NAME="QUICK_START">QUICK START</A></H1>
<P>
Spreadsheet::WriteExcel tries to provide an interface to as many of Excel's
features as possible. As a result there is a lot of documentation to
accompany the interface and it can be difficult at first glance to see what
it important and what is not. So for those of you who prefer to assemble
Ikea furniture first and then read the instructions, here are three easy
steps:

</P>
<P>
1. Create a new Excel <EM>workbook</EM> (i.e. file) using <CODE>new()</CODE>.

</P>
<P>
2. Add a <EM>worksheet</EM> to the new workbook using <CODE>add_worksheet()</CODE>.

</P>
<P>
3. Write to the worksheet using <CODE>write()</CODE>.

</P>
<P>
Like this:

</P>
<P>
<PRE>
    use Spreadsheet::WriteExcel;                             # Step 0
</PRE>
</P>
<P>
<PRE>
    my $workbook = Spreadsheet::WriteExcel-&gt;new('perl.xls'); # Step 1
    $worksheet   = $workbook-&gt;add_worksheet();               # Step 2
    $worksheet-&gt;write('A1', 'Hi Excel!');                    # Step 3
</PRE>
</P>
<P>
This will create an Excel file called <CODE>perl.xls</CODE> with a single worksheet and the text <CODE>'Hi Excel!'</CODE> in the relevant cell. And that's it. Okay, so there is actually a zeroth
step as well, but <CODE>use module</CODE> goes without saying. There are also more than 80 examples that come with
the distribution and which you can use to get you started. See <A HREF="#EXAMPLES">EXAMPLES</A>.

</P>
<P>
Those of you who read the instructions first and assemble the furniture
afterwards will know how to proceed. ;-)

</P>
<P>
<HR>
<H1><A NAME="WORKBOOK_METHODS">WORKBOOK METHODS</A></H1>
<P>
The Spreadsheet::WriteExcel module provides an object oriented interface to
a new Excel workbook. The following methods are available through a new
workbook.

</P>
<P>
<PRE>
    new()
    close()
    set_tempdir()
    add_worksheet()
    add_chart_ext()
    add_format()
    set_custom_color()
    sheets()
    set_1904()
    set_codepage()
</PRE>
</P>
<P>
If you are unfamiliar with object oriented interfaces or the way that they
are implemented in Perl have a look at <CODE>perlobj</CODE> and <CODE>perltoot</CODE> in the main Perl documentation.

</P>
<P>
<HR>
<H2><A NAME="new_">new()</A></H2>
<P>
A new Excel workbook is created using the <CODE>new()</CODE> constructor which accepts either a filename or a filehandle as a parameter.
The following example creates a new Excel file based on a filename:

</P>
<P>
<PRE>
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('filename.xls');
    my $worksheet = $workbook-&gt;add_worksheet();
    $worksheet-&gt;write(0, 0, 'Hi Excel!');
</PRE>
</P>
<P>
Here are some other examples of using <CODE>new()</CODE> with filenames:

</P>
<P>
<PRE>
    my $workbook1 = Spreadsheet::WriteExcel-&gt;new($filename);
    my $workbook2 = Spreadsheet::WriteExcel-&gt;new('/tmp/filename.xls');
    my $workbook3 = Spreadsheet::WriteExcel-&gt;new(&quot;c:\\tmp\\filename.xls&quot;);
    my $workbook4 = Spreadsheet::WriteExcel-&gt;new('c:\tmp\filename.xls');
</PRE>
</P>
<P>
The last two examples demonstrates how to create a file on DOS or Windows
where it is necessary to either escape the directory separator <CODE>\</CODE> or to use single quotes to ensure that it isn't interpolated. For more
information see <CODE>perlfaq5: Why can't I use &quot;C:\temp\foo&quot; in DOS paths?</CODE>.

</P>
<P>
The <CODE>new()</CODE> constructor returns a Spreadsheet::WriteExcel object that you can use to
add worksheets and store data. It should be noted that although <CODE>my</CODE> is not specifically required it defines the scope of the new workbook
variable and, in the majority of cases, ensures that the workbook is closed
properly without explicitly calling the <CODE>close()</CODE> method.

</P>
<P>
If the file cannot be created, due to file permissions or some other
reason,  <CODE>new</CODE> will return <CODE>undef</CODE>. Therefore, it is good practice to check the return value of <CODE>new</CODE> before proceeding. As usual the Perl variable <CODE>$!</CODE> will be set if there is a file creation error. You will also see one of the
warning messages detailed in <A HREF="#DIAGNOSTICS">DIAGNOSTICS</A>:

</P>
<P>
<PRE>
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('protected.xls');
    die &quot;Problems creating new Excel file: $!&quot; unless defined $workbook;
</PRE>
</P>
<P>
You can also pass a valid filehandle to the <CODE>new()</CODE> constructor. For example in a CGI program you could do something like this:

</P>
<P>
<PRE>
    binmode(STDOUT);
    my $workbook  = Spreadsheet::WriteExcel-&gt;new(\*STDOUT);
</PRE>
</P>
<P>
The requirement for <CODE>binmode()</CODE> is explained below.

</P>
<P>
For CGI programs you can also use the special Perl filename <CODE>'-'</CODE> which will redirect the output to STDOUT:

</P>
<P>
<PRE>
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('-');
</PRE>
</P>
<P>
See also, the <CODE>cgi.pl</CODE> program in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
However, this special case will not work in <CODE>mod_perl</CODE> programs where you will have to do something like the following:

</P>
<P>
<PRE>
    # mod_perl 1
    ...
    tie *XLS, 'Apache';
    binmode(XLS);
    my $workbook  = Spreadsheet::WriteExcel-&gt;new(\*XLS);
    ...
</PRE>
</P>
<P>
<PRE>
    # mod_perl 2
    ...
    tie *XLS =&gt; $r;  # Tie to the Apache::RequestRec object
    binmode(*XLS);
    my $workbook  = Spreadsheet::WriteExcel-&gt;new(\*XLS);
    ...
</PRE>
</P>
<P>
See also, the <CODE>mod_perl1.pl</CODE> and <CODE>mod_perl2.pl</CODE> programs in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
Filehandles can also be useful if you want to stream an Excel file over a
socket or if you want to store an Excel file in a scalar.

</P>
<P>
For example here is a way to write an Excel file to a scalar with <CODE>perl 5.8</CODE>:

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    # Requires perl 5.8 or later
    open my $fh, '&gt;', \my $str or die &quot;Failed to open filehandle: $!&quot;;
</PRE>
</P>
<P>
<PRE>
    my $workbook  = Spreadsheet::WriteExcel-&gt;new($fh);
    my $worksheet = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(0, 0,  'Hi Excel!');
</PRE>
</P>
<P>
<PRE>
    $workbook-&gt;close();
</PRE>
</P>
<P>
<PRE>
    # The Excel file in now in $str. Remember to binmode() the output
    # filehandle before printing it.
    binmode STDOUT;
    print $str;
</PRE>
</P>
<P>
See also the <CODE>write_to_scalar.pl</CODE> and <CODE>filehandle.pl</CODE> programs in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
<STRONG>Note about the requirement for</STRONG>  <CODE>binmode()</CODE>: An Excel file is comprised of binary data. Therefore, if you are using a
filehandle you should ensure that you <CODE>binmode()</CODE> it prior to passing it to <CODE>new()</CODE>.You should do this regardless of whether you are on a Windows platform or
not. This applies especially to users of perl 5.8 on systems where <CODE>UTF-8</CODE> is likely to be in operation such as RedHat Linux 9. If your program,
either intentionally or not, writes <CODE>UTF-8</CODE> data to a filehandle that is passed to <CODE>new()</CODE> it will corrupt the Excel file that is created.

</P>
<P>
You don't have to worry about <CODE>binmode()</CODE> if you are using filenames instead of filehandles. Spreadsheet::WriteExcel
performs the <CODE>binmode()</CODE> internally when it converts the filename to a filehandle. For more
information about <CODE>binmode()</CODE> see <CODE>perlfunc</CODE> and <CODE>perlopentut</CODE> in the main Perl documentation.

</P>
<P>
<HR>
<H2><A NAME="add_worksheet_sheetname_utf_1">add_worksheet($sheetname, $utf_16_be)</A></H2>
<P>
At least one worksheet should be added to a new workbook. A worksheet is
used to write data into cells:

</P>
<P>
<PRE>
    $worksheet1 = $workbook-&gt;add_worksheet();           # Sheet1
    $worksheet2 = $workbook-&gt;add_worksheet('Foglio2');  # Foglio2
    $worksheet3 = $workbook-&gt;add_worksheet('Data');     # Data
    $worksheet4 = $workbook-&gt;add_worksheet();           # Sheet4
</PRE>
</P>
<P>
If <CODE>$sheetname</CODE> is not specified the default Excel convention will be followed, i.e.
Sheet1, Sheet2, etc. The <CODE>$utf_16_be</CODE> parameter is optional, see below.

</P>
<P>
The worksheet name must be a valid Excel worksheet name, i.e. it cannot
contain any of the following characters, <CODE>[ ] : * ? / \</CODE> and it must be less than 32 characters. In addition, you cannot use the
same, case insensitive, <CODE>$sheetname</CODE> for more than one worksheet.

</P>
<P>
On systems with <CODE>perl 5.8</CODE> and later the <CODE>add_worksheet()</CODE> method will also handle strings in <CODE>UTF-8</CODE> format.

</P>
<P>
<PRE>
    $worksheet = $workbook-&gt;add_worksheet(&quot;\x{263a}&quot;); # Smiley
</PRE>
</P>
<P>
On earlier Perl systems your can specify <CODE>UTF-16BE</CODE> worksheet names using an additional optional parameter:

</P>
<P>
<PRE>
    my $name = pack 'n', 0x263a;
    $worksheet = $workbook-&gt;add_worksheet($name, 1);   # Smiley
</PRE>
</P>
<P>
<HR>
<H2><A NAME="add_format_properties_">add_format(%properties)</A></H2>
<P>
The <CODE>add_format()</CODE> method can be used to create new Format objects which are used to apply
formatting to a cell. You can either define the properties at creation time
via a hash of property values or later via method calls.

</P>
<P>
<PRE>
    $format1 = $workbook-&gt;add_format(%props); # Set properties at creation
    $format2 = $workbook-&gt;add_format();       # Set properties later
</PRE>
</P>
<P>
See the <A HREF="#CELL_FORMATTING">CELL FORMATTING</A> section for more details about Format properties and how to set them.

</P>
<P>
<HR>
<H2><A NAME="add_chart_ext_chart_data_char">add_chart_ext($chart_data, $chartname)</A></H2>
<P>
This method is use to include externally generated charts in a
Spreadsheet::WriteExcel file.

</P>
<P>
<PRE>
    my $chart = $workbook-&gt;add_chart_ext('chart01.bin', 'Chart1');
</PRE>
</P>
<P>
This feature is new and would be best described as experimental. Read <CODE>charts.txt</CODE> in the charts directory of the distro for a full explanation.

</P>
<P>
<HR>
<H2><A NAME="close_">close()</A></H2>
<P>
In general your Excel file will be closed automatically when your program
ends or when the Workbook object goes out of scope, however the <CODE>close()</CODE> method can be used to explicitly close an Excel file.

</P>
<P>
<PRE>
    $workbook-&gt;close();
</PRE>
</P>
<P>
An explicit <CODE>close()</CODE> is required if the file must be closed prior to performing some external
action on it such as copying it, reading its size or attaching it to an
email.

</P>
<P>
In addition, <CODE>close()</CODE> may be required to prevent perl's garbage collector from disposing of the
Workbook, Worksheet and Format objects in the wrong order. Situations where
this can occur are:

</P>
<UL>
<LI>
<P>
If <CODE>my()</CODE> was not used to declare the scope of a workbook variable created using <CODE>new()</CODE>.

</P>
<LI>
<P>
If the <CODE>new()</CODE>, <CODE>add_worksheet()</CODE> or <CODE>add_format()</CODE> methods are called in subroutines.

</P>
</UL>
<P>
The reason for this is that Spreadsheet::WriteExcel relies on Perl's <CODE>DESTROY</CODE> mechanism to trigger destructor methods in a specific sequence. This may
not happen in cases where the Workbook, Worksheet and Format variables are
not lexically scoped or where they have different lexical scopes.

</P>
<P>
In general, if you create a file with a size of 0 bytes or you fail to
create a file you need to call <CODE>close()</CODE>.

</P>
<P>
The return value of <CODE>close()</CODE> is the same as that returned by perl when it closes the file created by <CODE>new()</CODE>. This allows you to handle error conditions in the usual way:

</P>
<P>
<PRE>
    $workbook-&gt;close() or die &quot;Error closing file: $!&quot;;
</PRE>
</P>
<P>
<HR>
<H2><A NAME="compatibility_mode_">compatibility_mode()</A></H2>
<P>
This method is used to improve compatibility with third party applications
that read Excel files.

</P>
<P>
<PRE>
    $workbook-&gt;compatibility_mode();
</PRE>
</P>
<P>
An Excel file is comprised of binary records that describe properties of a
spreadsheet. Excel is reasonably liberal about this and, outside of a core
subset, it doesn't require every possible record to be present when it
reads a file. This is also true of Gnumeric and OpenOffice.Org Calc.

</P>
<P>
Spreadsheet::WriteExcel takes advantage of this fact to omit some records
in order to minimise the amount of data stored in memory and to simplify
and speed up the writing of files. However, some third party applications
that read Excel files often expect certain records to be present. In
"compatibility mode" Spreadsheet::WriteExcel writes these records and tries
to be as close to an Excel generated file as possible.

</P>
<P>
Applications that require <CODE>compatibility_mode()</CODE> are Apache POI, and Quickoffice on Nokia, Palm and other devices. You
should also use <CODE>compatibility_mode()</CODE> if your Excel file will be used as an external data source by another Excel
file.

</P>
<P>
If you encounter other situations that require <CODE>compatibility_mode()</CODE>, please let me know.

</P>
<P>
It should be noted that <CODE>compatibility_mode()</CODE> requires additional data to be stored in memory and additonal processing.
This incurs a memory and speed penalty and may not be suitable for very
large files (&gt;20MB).

</P>
<P>
You must call <CODE>compatibility_mode()</CODE> before calling <CODE>add_worksheet()</CODE>.

</P>
<P>
<HR>
<H2><A NAME="set_tempdir_">set_tempdir()</A></H2>
<P>
For speed and efficiency <CODE>Spreadsheet::WriteExcel</CODE> stores worksheet data in temporary files prior to assembling the final
workbook.

</P>
<P>
If Spreadsheet::WriteExcel is unable to create these temporary files it
will store the required data in memory. This can be slow for large files.

</P>
<P>
The problem occurs mainly with IIS on Windows although it could feasibly
occur on Unix systems as well. The problem generally occurs because the
default temp file directory is defined as <CODE>C:/</CODE> or some other directory that IIS doesn't provide write access to.

</P>
<P>
To check if this might be a problem on a particular system you can run a
simple test program with <CODE>-w</CODE> or <CODE>use warnings</CODE>. This will generate a warning if the module cannot create the required
temporary files:

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('test.xls');
    my $worksheet = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
To avoid this problem the <CODE>set_tempdir()</CODE> method can be used to specify a directory that is accessible for the
creation of temporary files.

</P>
<P>
The <CODE>File::Temp</CODE> module is used to create the temporary files. File::Temp uses <CODE>File::Spec</CODE> to determine an appropriate location for these files such as <CODE>/tmp</CODE> or <CODE>c:\windows\temp</CODE>. You can find out which directory is used on your system as follows:

</P>
<P>
<PRE>
    perl -MFile::Spec -le &quot;print File::Spec-&gt;tmpdir&quot;
</PRE>
</P>
<P>
Even if the default temporary file directory is accessible you may wish to
specify an alternative location for security or maintenance reasons:

</P>
<P>
<PRE>
    $workbook-&gt;set_tempdir('/tmp/writeexcel');
    $workbook-&gt;set_tempdir('c:\windows\temp\writeexcel');
</PRE>
</P>
<P>
The directory for the temporary file must exist, <CODE>set_tempdir()</CODE> will not create a new directory.

</P>
<P>
One disadvantage of using the <CODE>set_tempdir()</CODE> method is that on some Windows systems it will limit you to approximately
800 concurrent tempfiles. This means that a single program running on one
of these systems will be limited to creating a total of 800 workbook and
worksheet objects. You can run multiple, non-concurrent programs to work
around this if necessary.

</P>
<P>
<HR>
<H2><A NAME="set_custom_color_index_red_">set_custom_color($index, $red, $green, $blue)</A></H2>
<P>
The <CODE>set_custom_color()</CODE> method can be used to override one of the built-in palette values with a
more suitable colour.

</P>
<P>
The value for <CODE>$index</CODE> should be in the range 8..63, see <A HREF="#COLOURS_IN_EXCEL">COLOURS IN EXCEL</A>.

</P>
<P>
The default named colours use the following indices:

</P>
<P>
<PRE>
     8   =&gt;   black
     9   =&gt;   white
    10   =&gt;   red
    11   =&gt;   lime
    12   =&gt;   blue
    13   =&gt;   yellow
    14   =&gt;   magenta
    15   =&gt;   cyan
    16   =&gt;   brown
    17   =&gt;   green
    18   =&gt;   navy
    20   =&gt;   purple
    22   =&gt;   silver
    23   =&gt;   gray
    33   =&gt;   pink
    53   =&gt;   orange
</PRE>
</P>
<P>
A new colour is set using its RGB (red green blue) components. The <CODE>$red</CODE>, <CODE>$green</CODE> and <CODE>$blue</CODE> values must be in the range 0..255. You can determine the required values
in Excel using the <CODE>Tools-&gt;Options-&gt;Colors-&gt;Modify</CODE> dialog.

</P>
<P>
The <CODE>set_custom_color()</CODE> workbook method can also be used with a HTML style <CODE>#rrggbb</CODE> hex value:

</P>
<P>
<PRE>
    $workbook-&gt;set_custom_color(40, 255,  102,  0   ); # Orange
    $workbook-&gt;set_custom_color(40, 0xFF, 0x66, 0x00); # Same thing
    $workbook-&gt;set_custom_color(40, '#FF6600'       ); # Same thing
</PRE>
</P>
<P>
<PRE>
    my $font = $workbook-&gt;add_format(color =&gt; 40); # Use the modified colour
</PRE>
</P>
<P>
The return value from <CODE>set_custom_color()</CODE> is the index of the colour that was changed:

</P>
<P>
<PRE>
    my $ferrari = $workbook-&gt;set_custom_color(40, 216, 12, 12);
</PRE>
</P>
<P>
<PRE>
    my $format  = $workbook-&gt;add_format(
                                        bg_color =&gt; $ferrari,
                                        pattern  =&gt; 1,
                                        border   =&gt; 1
                                      );
</PRE>
</P>
<P>
<HR>
<H2><A NAME="sheets_0_1_">sheets(0, 1, ...)</A></H2>
<P>
The <CODE>sheets()</CODE> method returns a list, or a sliced list, of the worksheets in a workbook.

</P>
<P>
If no arguments are passed the method returns a list of all the worksheets
in the workbook. This is useful if you want to repeat an operation on each
worksheet:

</P>
<P>
<PRE>
    foreach $worksheet ($workbook-&gt;sheets()) {
       print $worksheet-&gt;get_name();
    }
</PRE>
</P>
<P>
You can also specify a slice list to return one or more worksheet objects:

</P>
<P>
<PRE>
    $worksheet = $workbook-&gt;sheets(0);
    $worksheet-&gt;write('A1', 'Hello');
</PRE>
</P>
<P>
Or since return value from <CODE>sheets()</CODE> is a reference to a worksheet object you can write the above example as:

</P>
<P>
<PRE>
    $workbook-&gt;sheets(0)-&gt;write('A1', 'Hello');
</PRE>
</P>
<P>
The following example returns the first and last worksheet in a workbook:

</P>
<P>
<PRE>
    foreach $worksheet ($workbook-&gt;sheets(0, -1)) {
       # Do something
    }
</PRE>
</P>
<P>
Array slices are explained in the perldata manpage.

</P>
<P>
<HR>
<H2><A NAME="set_1904_">set_1904()</A></H2>
<P>
Excel stores dates as real numbers where the integer part stores the number
of days since the epoch and the fractional part stores the percentage of
the day. The epoch can be either 1900 or 1904. Excel for Windows uses 1900
and Excel for Macintosh uses 1904. However, Excel on either platform will
convert automatically between one system and the other.

</P>
<P>
Spreadsheet::WriteExcel stores dates in the 1900 format by default. If you
wish to change this you can call the <CODE>set_1904()</CODE> workbook method. You can query the current value by calling the <CODE>get_1904()</CODE> workbook method. This returns 0 for 1900 and 1 for 1904.

</P>
<P>
See also <A HREF="#DATES_AND_TIME_IN_EXCEL">DATES AND TIME IN EXCEL</A> for more information about working with Excel's date system.

</P>
<P>
In general you probably won't need to use <CODE>set_1904()</CODE>.

</P>
<P>
<HR>
<H2><A NAME="set_codepage_codepage_">set_codepage($codepage)</A></H2>
<P>
The default code page or character set used by Spreadsheet::WriteExcel is
ANSI. This is also the default used by Excel for Windows. Occasionally
however it may be necessary to change the code page via the <CODE>set_codepage()</CODE> method.

</P>
<P>
Changing the code page may be required if your are using
Spreadsheet::WriteExcel on the Macintosh and you are using characters
outside the ASCII 128 character set:

</P>
<P>
<PRE>
    $workbook-&gt;set_codepage(1); # ANSI, MS Windows
    $workbook-&gt;set_codepage(2); # Apple Macintosh
</PRE>
</P>
<P>
The <CODE>set_codepage()</CODE> method is rarely required.

</P>
<P>
<HR>
<H1><A NAME="WORKSHEET_METHODS">WORKSHEET METHODS</A></H1>
<P>
A new worksheet is created by calling the <CODE>add_worksheet()</CODE> method from a workbook object:

</P>
<P>
<PRE>
    $worksheet1 = $workbook-&gt;add_worksheet();
    $worksheet2 = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
The following methods are available through a new worksheet:

</P>
<P>
<PRE>
    write()
    write_number()
    write_string()
    write_utf16be_string()
    write_utf16le_string()
    keep_leading_zeros()
    write_blank()
    write_row()
    write_col()
    write_date_time()
    write_url()
    write_url_range()
    write_formula()
    store_formula()
    repeat_formula()
    write_comment()
    show_comments()
    add_write_handler()
    insert_image()
    embed_chart()
    get_name()
    activate()
    select()
    hide()
    set_first_sheet()
    protect()
    set_selection()
    set_row()
    set_column()
    outline_settings()
    freeze_panes()
    split_panes()
    merge_range()
    set_zoom()
    right_to_left()
    hide_zero()
    set_tab_color()
    autofilter()
    filter_column()
</PRE>
</P>
<P>
<HR>
<H2><A NAME="Cell_notation">Cell notation</A></H2>
<P>
Spreadsheet::WriteExcel supports two forms of notation to designate the
position of cells: Row-column notation and A1 notation.

</P>
<P>
Row-column notation uses a zero based index for both row and column while
A1 notation uses the standard Excel alphanumeric sequence of column letter
and 1-based row. For example:

</P>
<P>
<PRE>
    (0, 0)      # The top left cell in row-column notation.
    ('A1')      # The top left cell in A1 notation.
</PRE>
</P>
<P>
<PRE>
    (1999, 29)  # Row-column notation.
    ('AD2000')  # The same cell in A1 notation.
</PRE>
</P>
<P>
Row-column notation is useful if you are referring to cells
programmatically:

</P>
<P>
<PRE>
    for my $i (0 .. 9) {
        $worksheet-&gt;write($i, 0, 'Hello'); # Cells A1 to A10
    }
</PRE>
</P>
<P>
A1 notation is useful for setting up a worksheet manually and for working
with formulas:

</P>
<P>
<PRE>
    $worksheet-&gt;write('H1', 200);
    $worksheet-&gt;write('H2', '=H1+1');
</PRE>
</P>
<P>
In formulas and applicable methods you can also use the <CODE>A:A</CODE> column notation:

</P>
<P>
<PRE>
    $worksheet-&gt;write('A1', '=SUM(B:B)');
</PRE>
</P>
<P>
The <CODE>Spreadsheet::WriteExcel::Utility</CODE> module that is included in the distro contains helper functions for dealing
with A1 notation, for example:

</P>
<P>
<PRE>
    use Spreadsheet::WriteExcel::Utility;
</PRE>
</P>
<P>
<PRE>
    ($row, $col)    = xl_cell_to_rowcol('C2');  # (1, 2)
    $str            = xl_rowcol_to_cell(1, 2);  # C2
</PRE>
</P>
<P>
For simplicity, the parameter lists for the worksheet method calls in the
following sections are given in terms of row-column notation. In all cases
it is also possible to use A1 notation.

</P>
<P>
Note: in Excel it is also possible to use a R1C1 notation. This is not
supported by Spreadsheet::WriteExcel.

</P>
<P>
<HR>
<H2><A NAME="write_row_column_token_fo">write($row, $column, $token, $format)</A></H2>
<P>
Excel makes a distinction between data types such as strings, numbers,
blanks, formulas and hyperlinks. To simplify the process of writing data
the <CODE>write()</CODE> method acts as a general alias for several more specific methods:

</P>
<P>
<PRE>
    write_string()
    write_number()
    write_blank()
    write_formula()
    write_url()
    write_row()
    write_col()
</PRE>
</P>
<P>
The general rule is that if the data looks like a <EM>something</EM> then a <EM>something</EM> is written. Here are some examples in both row-column and A1 notation:

</P>
<P>
<PRE>
                                                      # Same as:
    $worksheet-&gt;write(0, 0, 'Hello'                ); # write_string()
    $worksheet-&gt;write(1, 0, 'One'                  ); # write_string()
    $worksheet-&gt;write(2, 0,  2                     ); # write_number()
    $worksheet-&gt;write(3, 0,  3.00001               ); # write_number()
    $worksheet-&gt;write(4, 0,  &quot;&quot;                    ); # write_blank()
    $worksheet-&gt;write(5, 0,  ''                    ); # write_blank()
    $worksheet-&gt;write(6, 0,  undef                 ); # write_blank()
    $worksheet-&gt;write(7, 0                         ); # write_blank()
    $worksheet-&gt;write(8, 0,  'http://www.perl.com/'); # write_url()
    $worksheet-&gt;write('A9',  'ftp://ftp.cpan.org/' ); # write_url()
    $worksheet-&gt;write('A10', 'internal:Sheet1!A1'  ); # write_url()
    $worksheet-&gt;write('A11', 'external:c:\foo.xls' ); # write_url()
    $worksheet-&gt;write('A12', '=A3 + 3*A4'          ); # write_formula()
    $worksheet-&gt;write('A13', '=SIN(PI()/4)'        ); # write_formula()
    $worksheet-&gt;write('A14', \@array               ); # write_row()
    $worksheet-&gt;write('A15', [\@array]             ); # write_col()
</PRE>
</P>
<P>
<PRE>
    # And if the keep_leading_zeros property is set:
    $worksheet-&gt;write('A16,  2                     ); # write_number()
    $worksheet-&gt;write('A17,  02                    ); # write_string()
    $worksheet-&gt;write('A18,  00002                 ); # write_string()
</PRE>
</P>
<P>
The "looks like" rule is defined by regular expressions:

</P>
<P>
<CODE>write_number()</CODE> if <CODE>$token</CODE> is a number based on the following regex: <CODE>$token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/</CODE>.

</P>
<P>
<CODE>write_string()</CODE> if <CODE>keep_leading_zeros()</CODE> is set and <CODE>$token</CODE> is an integer with leading zeros based on the following regex: <CODE>$token =~ /^0\d+$/</CODE>.

</P>
<P>
<CODE>write_blank()</CODE> if <CODE>$token</CODE> is undef or a blank string: <CODE>undef</CODE>, <CODE>&quot;&quot;</CODE> or <CODE>''</CODE>.

</P>
<P>
<CODE>write_url()</CODE> if <CODE>$token</CODE> is a http, https, ftp or mailto URL based on the following regexes: <CODE>$token =~ m|^[fh]tt?ps?://|</CODE> or  <CODE>$token =~ m|^mailto:|</CODE>.

</P>
<P>
<CODE>write_url()</CODE> if <CODE>$token</CODE> is an internal or external sheet reference based on the following regex: <CODE>$token =~ m[^(in|ex)ternal:]</CODE>.

</P>
<P>
<CODE>write_formula()</CODE> if the first character of <CODE>$token</CODE> is <CODE>&quot;=&quot;</CODE>.

</P>
<P>
<CODE>write_row()</CODE> if <CODE>$token</CODE> is an array ref.

</P>
<P>
<CODE>write_col()</CODE> if <CODE>$token</CODE> is an array ref of array refs.

</P>
<P>
<CODE>write_string()</CODE> if none of the previous conditions apply.

</P>
<P>
The <CODE>$format</CODE> parameter is optional. It should be a valid Format object, see <A HREF="#CELL_FORMATTING">CELL FORMATTING</A>:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_bold();
    $format-&gt;set_color('red');
    $format-&gt;set_align('center');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(4, 0, 'Hello', $format); # Formatted string
</PRE>
</P>
<P>
The <CODE>write()</CODE> method will ignore empty strings or <CODE>undef</CODE> tokens unless a format is also supplied. As such you needn't worry about
special handling for empty or <CODE>undef</CODE> values in your data. See also the <CODE>write_blank()</CODE> method.

</P>
<P>
One problem with the <CODE>write()</CODE> method is that occasionally data looks like a number but you don't want it
treated as a number. For example, zip codes or ID numbers often start with
a leading zero. If you write this data as a number then the leading
<CODE>zero(s)</CODE> will be stripped. You can change this default
behaviour by using the <CODE>keep_leading_zeros()</CODE> method. While this property is in place any integers with leading zeros
will be treated as strings and the zeros will be preserved. See the <CODE>keep_leading_zeros()</CODE> section for a full discussion of this issue.

</P>
<P>
You can also add your own data handlers to the <CODE>write()</CODE> method using <CODE>add_write_handler()</CODE>.

</P>
<P>
On systems with <CODE>perl 5.8</CODE> and later the <CODE>write()</CODE> method will also handle Unicode strings in <CODE>UTF-8</CODE> format.

</P>
<P>
The <CODE>write</CODE> methods return:

</P>
<P>
<PRE>
    0 for success.
   -1 for insufficient number of arguments.
   -2 for row or column out of bounds.
   -3 for string too long.
</PRE>
</P>
<P>
<HR>
<H2><A NAME="write_number_row_column_num">write_number($row, $column, $number, $format)</A></H2>
<P>
Write an integer or a float to the cell specified by <CODE>$row</CODE> and <CODE>$column</CODE>:

</P>
<P>
<PRE>
    $worksheet-&gt;write_number(0, 0,  123456);
    $worksheet-&gt;write_number('A2',  2.3451);
</PRE>
</P>
<P>
See the note about <A HREF="#Cell_notation">Cell notation</A>. The <CODE>$format</CODE> parameter is optional.

</P>
<P>
In general it is sufficient to use the <CODE>write()</CODE> method.

</P>
<P>
<HR>
<H2><A NAME="write_string_row_column_str">write_string($row, $column, $string, $format)</A></H2>
<P>
Write a string to the cell specified by <CODE>$row</CODE> and <CODE>$column</CODE>:

</P>
<P>
<PRE>
    $worksheet-&gt;write_string(0, 0, 'Your text here' );
    $worksheet-&gt;write_string('A2', 'or here' );
</PRE>
</P>
<P>
The maximum string size is 32767 characters. However the maximum string
segment that Excel can display in a cell is 1000. All 32767 characters can
be displayed in the formula bar.

</P>
<P>
The <CODE>$format</CODE> parameter is optional.

</P>
<P>
On systems with <CODE>perl 5.8</CODE> and later the <CODE>write()</CODE> method will also handle strings in <CODE>UTF-8</CODE> format. With older perls you can also write Unicode in <CODE>UTF16</CODE> format via the <CODE>write_utf16be_string()</CODE> method. See also the <CODE>unicode_*.pl</CODE> programs in the examples directory of the distro.

</P>
<P>
In general it is sufficient to use the <CODE>write()</CODE> method. However, you may sometimes wish to use the <CODE>write_string()</CODE> method to write data that looks like a number but that you don't want
treated as a number. For example, zip codes or phone numbers:

</P>
<P>
<PRE>
    # Write as a plain string
    $worksheet-&gt;write_string('A1', '01209');
</PRE>
</P>
<P>
However, if the user edits this string Excel may convert it back to a
number. To get around this you can use the Excel text format <CODE>@</CODE>:

</P>
<P>
<PRE>
    # Format as a string. Doesn't change to a number when edited
    my $format1 = $workbook-&gt;add_format(num_format =&gt; '@');
    $worksheet-&gt;write_string('A2', '01209', $format1);
</PRE>
</P>
<P>
See also the note about <A HREF="#Cell_notation">Cell notation</A>.

</P>
<P>
<HR>
<H2><A NAME="write_utf16be_string_row_colu">write_utf16be_string($row, $column, $string, $format)</A></H2>
<P>
This method is used to write <CODE>UTF-16BE</CODE> strings to a cell in Excel. It is functionally the same as the <CODE>write_string()</CODE> method except that the string should be in <CODE>UTF-16BE</CODE> Unicode format. It is generally easier, when using Spreadsheet::WriteExcel,
to write unicode strings in <CODE>UTF-8</CODE> format, see <A HREF="#UNICODE_IN_EXCEL">UNICODE IN EXCEL</A>. The <CODE>write_utf16be_string()</CODE> method is mainly of use in versions of perl prior to 5.8.

</P>
<P>
The following is a simple example showing how to write some Unicode strings
in <CODE>UTF-16BE</CODE> format:

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
    use Unicode::Map();
</PRE>
</P>
<P>
<PRE>
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('utf_16_be.xls');
    my $worksheet = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    # Increase the column width for clarity
    $worksheet-&gt;set_column('A:A', 25);
</PRE>
</P>
<P>
<PRE>
    # Write a Unicode character
    #
    my $smiley = pack 'n', 0x263a;
</PRE>
</P>
<P>
<PRE>
    # Increase the font size for legibility.
    my $big_font = $workbook-&gt;add_format(size =&gt; 72);
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write_utf16be_string('A3', $smiley, $big_font);
</PRE>
</P>
<P>
<PRE>
    # Write a phrase in Cyrillic using a hex-encoded string
    #
    my $str = pack 'H*', '042d0442043e0020044404400430043704300020043d' .
                         '043000200440044304410441043a043e043c0021';
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write_utf16be_string('A5', $str);
</PRE>
</P>
<P>
<PRE>
    # Map a string to UTF-16BE using an external module.
    #
    my $map   = Unicode::Map-&gt;new('ISO-8859-1');
    my $utf16 = $map-&gt;to_unicode('Hello world!');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write_utf16be_string('A7', $utf16);
</PRE>
</P>
<P>
You can convert ASCII encodings to the required <CODE>UTF-16BE</CODE> format using one of the many Unicode modules on CPAN. For example <CODE>Unicode::Map</CODE> and <CODE>Unicode::String</CODE>: <A
HREF="http://search.cpan.org/author/MSCHWARTZ/Unicode-Map/Map.pm">http://search.cpan.org/author/MSCHWARTZ/Unicode-Map/Map.pm</A>
and <A
HREF="http://search.cpan.org/author/GAAS/Unicode-String/String.pm">http://search.cpan.org/author/GAAS/Unicode-String/String.pm</A>


</P>
<P>
For a full list of the Perl Unicode modules see: <A
HREF="http://search.cpan.org/search?query=unicode&mode=all">http://search.cpan.org/search?query=unicode&mode=all</A>


</P>
<P>
<CODE>UTF-16BE</CODE> is the format most often returned by <CODE>Perl</CODE> modules that generate <CODE>UTF-16</CODE>. To write <CODE>UTF-16</CODE> strings in little-endian format use the <CODE>write_utf16be_string_le()</CODE> method below.

</P>
<P>
The <CODE>write_utf16be_string()</CODE> method was previously called <CODE>write_unicode()</CODE>. That, overly general, name is still supported but deprecated.

</P>
<P>
See also the <CODE>unicode_*.pl</CODE> programs in the examples directory of the distro.

</P>
<P>
<HR>
<H2><A NAME="write_utf16le_string_row_colu">write_utf16le_string($row, $column, $string, $format)</A></H2>
<P>
This method is the same as <CODE>write_utf16be()</CODE> except that the string should be 16-bit characters in little-endian format.
This is generally referred to as <CODE>UTF-16LE</CODE>. See <A HREF="#UNICODE_IN_EXCEL">UNICODE IN EXCEL</A>.

</P>
<P>
<CODE>UTF-16</CODE> data can be changed from little-endian to big-endian format (and
vice-versa) as follows:

</P>
<P>
<PRE>
    $utf16be = pack 'n*', unpack 'v*', $utf16le;
</PRE>
</P>
<P>
<HR>
<H2><A NAME="keep_leading_zeros_">keep_leading_zeros()</A></H2>
<P>
This method changes the default handling of integers with leading zeros
when using the <CODE>write()</CODE> method.

</P>
<P>
The <CODE>write()</CODE> method uses regular expressions to determine what type of data to write to
an Excel worksheet. If the data looks like a number it writes a number
using <CODE>write_number()</CODE>. One problem with this approach is that occasionally data looks like a
number but you don't want it treated as a number.

</P>
<P>
Zip codes and ID numbers, for example, often start with a leading zero. If
you write this data as a number then the leading <CODE>zero(s)</CODE> will
be stripped. This is the also the default behaviour when you enter data
manually in Excel.

</P>
<P>
To get around this you can use one of three options. Write a formatted
number, write the number as a string or use the <CODE>keep_leading_zeros()</CODE> method to change the default behaviour of <CODE>write()</CODE>:

</P>
<P>
<PRE>
    # Implicitly write a number, the leading zero is removed: 1209
    $worksheet-&gt;write('A1', '01209');
</PRE>
</P>
<P>
<PRE>
    # Write a zero padded number using a format: 01209
    my $format1 = $workbook-&gt;add_format(num_format =&gt; '00000');
    $worksheet-&gt;write('A2', '01209', $format1);
</PRE>
</P>
<P>
<PRE>
    # Write explicitly as a string: 01209
    $worksheet-&gt;write_string('A3', '01209');
</PRE>
</P>
<P>
<PRE>
    # Write implicitly as a string: 01209
    $worksheet-&gt;keep_leading_zeros();
    $worksheet-&gt;write('A4', '01209');
</PRE>
</P>
<P>
The above code would generate a worksheet that looked like the following:

</P>
<P>
<PRE>
     -----------------------------------------------------------
    |   |     A     |     B     |     C     |     D     | ...
     -----------------------------------------------------------
    | 1 |      1209 |           |           |           | ...
    | 2 |     01209 |           |           |           | ...
    | 3 | 01209     |           |           |           | ...
    | 4 | 01209     |           |           |           | ...
</PRE>
</P>
<P>
The examples are on different sides of the cells due to the fact that Excel
displays strings with a left justification and numbers with a right
justification by default. You can change this by using a format to justify
the data, see <A HREF="#CELL_FORMATTING">CELL FORMATTING</A>.

</P>
<P>
It should be noted that if the user edits the data in examples <CODE>A3</CODE> and <CODE>A4</CODE> the strings will revert back to numbers. Again this is Excel's default
behaviour. To avoid this you can use the text format <CODE>@</CODE>:

</P>
<P>
<PRE>
    # Format as a string (01209)
    my $format2 = $workbook-&gt;add_format(num_format =&gt; '@');
    $worksheet-&gt;write_string('A5', '01209', $format2);
</PRE>
</P>
<P>
The <CODE>keep_leading_zeros()</CODE> property is off by default. The <CODE>keep_leading_zeros()</CODE> method takes 0 or 1 as an argument. It defaults to 1 if an argument isn't
specified:

</P>
<P>
<PRE>
    $worksheet-&gt;keep_leading_zeros();  # Set on
    $worksheet-&gt;keep_leading_zeros(1); # Set on
    $worksheet-&gt;keep_leading_zeros(0); # Set off
</PRE>
</P>
<P>
See also the <CODE>add_write_handler()</CODE> method.

</P>
<P>
<HR>
<H2><A NAME="write_blank_row_column_form">write_blank($row, $column, $format)</A></H2>
<P>
Write a blank cell specified by <CODE>$row</CODE> and <CODE>$column</CODE>:

</P>
<P>
<PRE>
    $worksheet-&gt;write_blank(0, 0, $format);
</PRE>
</P>
<P>
This method is used to add formatting to a cell which doesn't contain a
string or number value.

</P>
<P>
Excel differentiates between an "Empty" cell and a "Blank" cell. An "Empty"
cell is a cell which doesn't contain data whilst a "Blank" cell is a cell
which doesn't contain data but does contain formatting. Excel stores
"Blank" cells but ignores "Empty" cells.

</P>
<P>
As such, if you write an empty cell without formatting it is ignored:

</P>
<P>
<PRE>
    $worksheet-&gt;write('A1',  undef, $format); # write_blank()
    $worksheet-&gt;write('A2',  undef         ); # Ignored
</PRE>
</P>
<P>
This seemingly uninteresting fact means that you can write arrays of data
without special treatment for undef or empty string values.

</P>
<P>
See the note about <A HREF="#Cell_notation">Cell notation</A>.

</P>
<P>
<HR>
<H2><A NAME="write_row_row_column_array_">write_row($row, $column, $array_ref, $format)</A></H2>
<P>
The <CODE>write_row()</CODE> method can be used to write a 1D or 2D array of data in one go. This is
useful for converting the results of a database query into an Excel
worksheet. You must pass a reference to the array of data rather than the
array itself. The <CODE>write()</CODE> method is then called for each element of the data. For example:

</P>
<P>
<PRE>
    @array      = ('awk', 'gawk', 'mawk');
    $array_ref  = \@array;
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write_row(0, 0, $array_ref);
</PRE>
</P>
<P>
<PRE>
    # The above example is equivalent to:
    $worksheet-&gt;write(0, 0, $array[0]);
    $worksheet-&gt;write(0, 1, $array[1]);
    $worksheet-&gt;write(0, 2, $array[2]);
</PRE>
</P>
<P>
Note: For convenience the <CODE>write()</CODE> method behaves in the same way as <CODE>write_row()</CODE> if it is passed an array reference. Therefore the following two method
calls are equivalent:

</P>
<P>
<PRE>
    $worksheet-&gt;write_row('A1', $array_ref); # Write a row of data
    $worksheet-&gt;write(    'A1', $array_ref); # Same thing
</PRE>
</P>
<P>
As with all of the write methods the <CODE>$format</CODE> parameter is optional. If a format is specified it is applied to all the
elements of the data array.

</P>
<P>
Array references within the data will be treated as columns. This allows
you to write 2D arrays of data in one go. For example:

</P>
<P>
<PRE>
    @eec =  (
                ['maggie', 'milly', 'molly', 'may'  ],
                [13,       14,      15,      16     ],
                ['shell',  'star',  'crab',  'stone']
            );
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write_row('A1', \@eec);
</PRE>
</P>
<P>
Would produce a worksheet as follows:

</P>
<P>
<PRE>
     -----------------------------------------------------------
    |   |    A    |    B    |    C    |    D    |    E    | ...
     -----------------------------------------------------------
    | 1 | maggie  | 13      | shell   | ...     |  ...    | ...
    | 2 | milly   | 14      | star    | ...     |  ...    | ...
    | 3 | molly   | 15      | crab    | ...     |  ...    | ...
    | 4 | may     | 16      | stone   | ...     |  ...    | ...
    | 5 | ...     | ...     | ...     | ...     |  ...    | ...
    | 6 | ...     | ...     | ...     | ...     |  ...    | ...
</PRE>
</P>
<P>
To write the data in a row-column order refer to the <CODE>write_col()</CODE> method below.

</P>
<P>
Any <CODE>undef</CODE> values in the data will be ignored unless a format is applied to the data,
in which case a formatted blank cell will be written. In either case the
appropriate row or column value will still be incremented.

</P>
<P>
To find out more about array references refer to <CODE>perlref</CODE> and <CODE>perlreftut</CODE> in the main Perl documentation. To find out more about 2D arrays or "lists
of lists" refer to <CODE>perllol</CODE>.

</P>
<P>
The <CODE>write_row()</CODE> method returns the first error encountered when writing the elements of the
data or zero if no errors were encountered. See the return values described
for the <CODE>write()</CODE> method above.

</P>
<P>
See also the <CODE>write_arrays.pl</CODE> program in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
The <CODE>write_row()</CODE> method allows the following idiomatic conversion of a text file to an Excel
file:

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('file.xls');
    my $worksheet = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    open INPUT, 'file.txt' or die &quot;Couldn't open file: $!&quot;;
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write($.-1, 0, [split]) while &lt;INPUT&gt;;
</PRE>
</P>
<P>
<HR>
<H2><A NAME="write_col_row_column_array_">write_col($row, $column, $array_ref, $format)</A></H2>
<P>
The <CODE>write_col()</CODE> method can be used to write a 1D or 2D array of data in one go. This is
useful for converting the results of a database query into an Excel
worksheet. You must pass a reference to the array of data rather than the
array itself. The <CODE>write()</CODE> method is then called for each element of the data. For example:

</P>
<P>
<PRE>
    @array      = ('awk', 'gawk', 'mawk');
    $array_ref  = \@array;
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write_col(0, 0, $array_ref);
</PRE>
</P>
<P>
<PRE>
    # The above example is equivalent to:
    $worksheet-&gt;write(0, 0, $array[0]);
    $worksheet-&gt;write(1, 0, $array[1]);
    $worksheet-&gt;write(2, 0, $array[2]);
</PRE>
</P>
<P>
As with all of the write methods the <CODE>$format</CODE> parameter is optional. If a format is specified it is applied to all the
elements of the data array.

</P>
<P>
Array references within the data will be treated as rows. This allows you
to write 2D arrays of data in one go. For example:

</P>
<P>
<PRE>
    @eec =  (
                ['maggie', 'milly', 'molly', 'may'  ],
                [13,       14,      15,      16     ],
                ['shell',  'star',  'crab',  'stone']
            );
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write_col('A1', \@eec);
</PRE>
</P>
<P>
Would produce a worksheet as follows:

</P>
<P>
<PRE>
     -----------------------------------------------------------
    |   |    A    |    B    |    C    |    D    |    E    | ...
     -----------------------------------------------------------
    | 1 | maggie  | milly   | molly   | may     |  ...    | ...
    | 2 | 13      | 14      | 15      | 16      |  ...    | ...
    | 3 | shell   | star    | crab    | stone   |  ...    | ...
    | 4 | ...     | ...     | ...     | ...     |  ...    | ...
    | 5 | ...     | ...     | ...     | ...     |  ...    | ...
    | 6 | ...     | ...     | ...     | ...     |  ...    | ...
</PRE>
</P>
<P>
To write the data in a column-row order refer to the <CODE>write_row()</CODE> method above.

</P>
<P>
Any <CODE>undef</CODE> values in the data will be ignored unless a format is applied to the data,
in which case a formatted blank cell will be written. In either case the
appropriate row or column value will still be incremented.

</P>
<P>
As noted above the <CODE>write()</CODE> method can be used as a synonym for <CODE>write_row()</CODE> and <CODE>write_row()</CODE> handles nested array refs as columns. Therefore, the following two method
calls are equivalent although the more explicit call to <CODE>write_col()</CODE> would be preferable for maintainability:

</P>
<P>
<PRE>
    $worksheet-&gt;write_col('A1', $array_ref    ); # Write a column of data
    $worksheet-&gt;write(    'A1', [ $array_ref ]); # Same thing
</PRE>
</P>
<P>
To find out more about array references refer to <CODE>perlref</CODE> and <CODE>perlreftut</CODE> in the main Perl documentation. To find out more about 2D arrays or "lists
of lists" refer to <CODE>perllol</CODE>.

</P>
<P>
The <CODE>write_col()</CODE> method returns the first error encountered when writing the elements of the
data or zero if no errors were encountered. See the return values described
for the <CODE>write()</CODE> method above.

</P>
<P>
See also the <CODE>write_arrays.pl</CODE> program in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
<HR>
<H2><A NAME="write_date_time_row_col_dat">write_date_time($row, $col, $date_string, $format)</A></H2>
<P>
The <CODE>write_date_time()</CODE> method can be used to write a date or time to the cell specified by <CODE>$row</CODE> and <CODE>$column</CODE>:

</P>
<P>
<PRE>
    $worksheet-&gt;write_date_time('A1', '2004-05-13T23:20', $date_format);
</PRE>
</P>
<P>
The <CODE>$date_string</CODE> should be in the following format:

</P>
<P>
<PRE>
    yyyy-mm-ddThh:mm:ss.sss
</PRE>
</P>
<P>
This conforms to an ISO8601 date but it should be noted that the full range
of ISO8601 formats are not supported.

</P>
<P>
The following variations on the <CODE>$date_string</CODE> parameter are permitted:

</P>
<P>
<PRE>
    yyyy-mm-ddThh:mm:ss.sss         # Standard format
    yyyy-mm-ddT                     # No time
              Thh:mm:ss.sss         # No date
    yyyy-mm-ddThh:mm:ss.sssZ        # Additional Z (but not time zones)
    yyyy-mm-ddThh:mm:ss             # No fractional seconds
    yyyy-mm-ddThh:mm                # No seconds
</PRE>
</P>
<P>
Note that the <CODE>T</CODE> is required in all cases.

</P>
<P>
A date should always have a <CODE>$format</CODE>, otherwise it will appear as a number, see <A HREF="#DATES_AND_TIME_IN_EXCEL">DATES AND TIME IN EXCEL</A> and <A HREF="#CELL_FORMATTING">CELL FORMATTING</A>. Here is a typical example:

</P>
<P>
<PRE>
    my $date_format = $workbook-&gt;add_format(num_format =&gt; 'mm/dd/yy');
    $worksheet-&gt;write_date_time('A1', '2004-05-13T23:20', $date_format);
</PRE>
</P>
<P>
Valid dates should be in the range 1900-01-01 to 9999-12-31, for the 1900
epoch and 1904-01-01 to 9999-12-31, for the 1904 epoch. As with Excel,
dates outside these ranges will be written as a string.

</P>
<P>
See also the date_time.pl program in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
<HR>
<H2><A NAME="write_url_row_col_url_lab">write_url($row, $col, $url, $label, $format)</A></H2>
<P>
Write a hyperlink to a URL in the cell specified by <CODE>$row</CODE> and <CODE>$column</CODE>. The hyperlink is comprised of two elements: the visible label and the
invisible link. The visible label is the same as the link unless an
alternative label is specified. The parameters <CODE>$label</CODE> and the <CODE>$format</CODE> are optional and their position is interchangeable.

</P>
<P>
The label is written using the <CODE>write()</CODE> method. Therefore it is possible to write strings, numbers or formulas as
labels.

</P>
<P>
There are four web style URI's supported: <CODE>http://</CODE>, <CODE>https://</CODE>, <CODE>ftp://</CODE> and  <CODE>mailto:</CODE>:

</P>
<P>
<PRE>
    $worksheet-&gt;write_url(0, 0,  'ftp://www.perl.org/'                  );
    $worksheet-&gt;write_url(1, 0,  'http://www.perl.com/', 'Perl home'    );
    $worksheet-&gt;write_url('A3',  'http://www.perl.com/', $format        );
    $worksheet-&gt;write_url('A4',  'http://www.perl.com/', 'Perl', $format);
    $worksheet-&gt;write_url('A5',  'mailto:jmcnamara@cpan.org'            );
</PRE>
</P>
<P>
There are two local URIs supported: <CODE>internal:</CODE> and <CODE>external:</CODE>. These are used for hyperlinks to internal worksheet references or
external workbook and worksheet references:

</P>
<P>
<PRE>
    $worksheet-&gt;write_url('A6',  'internal:Sheet2!A1'                   );
    $worksheet-&gt;write_url('A7',  'internal:Sheet2!A1',   $format        );
    $worksheet-&gt;write_url('A8',  'internal:Sheet2!A1:B2'                );
    $worksheet-&gt;write_url('A9',  q{internal:'Sales Data'!A1}            );
    $worksheet-&gt;write_url('A10', 'external:c:\temp\foo.xls'             );
    $worksheet-&gt;write_url('A11', 'external:c:\temp\foo.xls#Sheet2!A1'   );
    $worksheet-&gt;write_url('A12', 'external:..\..\..\foo.xls'            );
    $worksheet-&gt;write_url('A13', 'external:..\..\..\foo.xls#Sheet2!A1'  );
    $worksheet-&gt;write_url('A13', 'external:\\\\NETWORK\share\foo.xls'   );
</PRE>
</P>
<P>
All of the these URI types are recognised by the <CODE>write()</CODE> method, see above.

</P>
<P>
Worksheet references are typically of the form <CODE>Sheet1!A1</CODE>. You can also refer to a worksheet range using the standard Excel
notation: <CODE>Sheet1!A1:B2</CODE>.

</P>
<P>
In external links the workbook and worksheet name must be separated by the <CODE>#</CODE> character: <CODE>external:Workbook.xls#Sheet1!A1'</CODE>.

</P>
<P>
You can also link to a named range in the target worksheet. For example say
you have a named range called <CODE>my_name</CODE> in the workbook <CODE>c:\temp\foo.xls</CODE> you could link to it as follows:

</P>
<P>
<PRE>
    $worksheet-&gt;write_url('A14', 'external:c:\temp\foo.xls#my_name');
</PRE>
</P>
<P>
Note, you cannot currently create named ranges with <CODE>Spreadsheet::WriteExcel</CODE>.

</P>
<P>
Excel requires that worksheet names containing spaces or non alphanumeric
characters are single quoted as follows <CODE>'Sales Data'!A1</CODE>. If you need to do this in a single quoted string then you can either
escape the single quotes <CODE>\'</CODE> or use the quote operator <CODE>q{}</CODE> as described in <CODE>perlop</CODE> in the main Perl documentation.

</P>
<P>
Links to network files are also supported. MS/Novell Network files normally
begin with two back slashes as follows <CODE>\\NETWORK\etc</CODE>. In order to generate this in a single or double quoted string you will
have to escape the backslashes,  <CODE>'\\\\NETWORK\etc'</CODE>.

</P>
<P>
If you are using double quote strings then you should be careful to escape
anything that looks like a metacharacter. For more information see <CODE>perlfaq5: Why can't I use &quot;C:\temp\foo&quot; in DOS paths?</CODE>.

</P>
<P>
Finally, you can avoid most of these quoting problems by using forward
slashes. These are translated internally to backslashes:

</P>
<P>
<PRE>
    $worksheet-&gt;write_url('A14', &quot;external:c:/temp/foo.xls&quot;             );
    $worksheet-&gt;write_url('A15', 'external://NETWORK/share/foo.xls'     );
</PRE>
</P>
<P>
See also, the note about <A HREF="#Cell_notation">Cell notation</A>.

</P>
<P>
<HR>
<H2><A NAME="write_url_range_row1_col1_r">write_url_range($row1, $col1, $row2, $col2, $url, $string, $format)</A></H2>
<P>
This method is essentially the same as the <CODE>write_url()</CODE> method described above. The main difference is that you can specify a link
for a range of cells:

</P>
<P>
<PRE>
    $worksheet-&gt;write_url(0, 0, 0, 3, 'ftp://www.perl.org/'              );
    $worksheet-&gt;write_url(1, 0, 0, 3, 'http://www.perl.com/', 'Perl home');
    $worksheet-&gt;write_url('A3:D3',    'internal:Sheet2!A1'               );
    $worksheet-&gt;write_url('A4:D4',    'external:c:\temp\foo.xls'         );
</PRE>
</P>
<P>
This method is generally only required when used in conjunction with merged
cells. See the <CODE>merge_range()</CODE> method and the <CODE>merge</CODE> property of a Format object, <A HREF="#CELL_FORMATTING">CELL FORMATTING</A>.

</P>
<P>
There is no way to force this behaviour through the <CODE>write()</CODE> method.

</P>
<P>
The parameters <CODE>$string</CODE> and the <CODE>$format</CODE> are optional and their position is interchangeable. However, they are
applied only to the first cell in the range.

</P>
<P>
See also, the note about <A HREF="#Cell_notation">Cell notation</A>.

</P>
<P>
<HR>
<H2><A NAME="write_formula_row_column_fo">write_formula($row, $column, $formula, $format, $value)</A></H2>
<P>
Write a formula or function to the cell specified by <CODE>$row</CODE> and <CODE>$column</CODE>:

</P>
<P>
<PRE>
    $worksheet-&gt;write_formula(0, 0, '=$B$3 + B4'  );
    $worksheet-&gt;write_formula(1, 0, '=SIN(PI()/4)');
    $worksheet-&gt;write_formula(2, 0, '=SUM(B1:B5)' );
    $worksheet-&gt;write_formula('A4', '=IF(A3&gt;1,&quot;Yes&quot;, &quot;No&quot;)'   );
    $worksheet-&gt;write_formula('A5', '=AVERAGE(1, 2, 3, 4)'    );
    $worksheet-&gt;write_formula('A6', '=DATEVALUE(&quot;1-Jan-2001&quot;)');
</PRE>
</P>
<P>
See the note about <A HREF="#Cell_notation">Cell notation</A>. For more information about writing Excel formulas see <A HREF="#FORMULAS_AND_FUNCTIONS_IN_EXCEL">FORMULAS AND FUNCTIONS IN EXCEL</A>



</P>
<P>
See also the section "Improving performance when working with formulas" and
the <CODE>store_formula()</CODE> and <CODE>repeat_formula()</CODE> methods.

</P>
<P>
If required, it is also possible to specify the calculated value of the
formula. This is occasionally necessary when working with non-Excel
applications that don't calculated the value of the formula. The calculated <CODE>$value</CODE> is added at the end of the argument list:

</P>
<P>
<PRE>
    $worksheet-&gt;write('A1', '=2+2', $format, 4);
</PRE>
</P>
<P>
However, this probably isn't something that will ever need to do. If you do
use this feature then do so with care.

</P>
<P>
<HR>
<H2><A NAME="store_formula_formula_">store_formula($formula)</A></H2>
<P>
The <CODE>store_formula()</CODE> method is used in conjunction with <CODE>repeat_formula()</CODE> to speed up the generation of repeated formulas. See "Improving performance
when working with formulas" in <A HREF="#FORMULAS_AND_FUNCTIONS_IN_EXCEL">FORMULAS AND FUNCTIONS IN EXCEL</A>.

</P>
<P>
The <CODE>store_formula()</CODE> method pre-parses a textual representation of a formula and stores it for
use at a later stage by the <CODE>repeat_formula()</CODE> method.

</P>
<P>
<CODE>store_formula()</CODE> carries the same speed penalty as <CODE>write_formula()</CODE>. However, in practice it will be used less frequently.

</P>
<P>
The return value of this method is a scalar that can be thought of as a
reference to a formula.

</P>
<P>
<PRE>
    my $sin = $worksheet-&gt;store_formula('=SIN(A1)');
    my $cos = $worksheet-&gt;store_formula('=COS(A1)');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;repeat_formula('B1', $sin, $format, 'A1', 'A2');
    $worksheet-&gt;repeat_formula('C1', $cos, $format, 'A1', 'A2');
</PRE>
</P>
<P>
Although <CODE>store_formula()</CODE> is a worksheet method the return value can be used in any worksheet:

</P>
<P>
<PRE>
    my $now = $worksheet-&gt;store_formula('=NOW()');
</PRE>
</P>
<P>
<PRE>
    $worksheet1-&gt;repeat_formula('B1', $now);
    $worksheet2-&gt;repeat_formula('B1', $now);
    $worksheet3-&gt;repeat_formula('B1', $now);
</PRE>
</P>
<P>
<HR>
<H2><A NAME="repeat_formula_row_col_form">repeat_formula($row, $col, $formula, $format, ($pattern =&gt; $replace, ...))</A></H2>
<P>
The <CODE>repeat_formula()</CODE> method is used in conjunction with <CODE>store_formula()</CODE> to speed up the generation of repeated formulas. See "Improving performance
when working with formulas" in <A HREF="#FORMULAS_AND_FUNCTIONS_IN_EXCEL">FORMULAS AND FUNCTIONS IN EXCEL</A>.

</P>
<P>
In many respects <CODE>repeat_formula()</CODE> behaves like <CODE>write_formula()</CODE> except that it is significantly faster.

</P>
<P>
The <CODE>repeat_formula()</CODE> method creates a new formula based on the pre-parsed tokens returned by <CODE>store_formula()</CODE>. The new formula is generated by substituting <CODE>$pattern</CODE>, <CODE>$replace</CODE> pairs in the stored formula:

</P>
<P>
<PRE>
    my $formula = $worksheet-&gt;store_formula('=A1 * 3 + 50');
</PRE>
</P>
<P>
<PRE>
    for my $row (0..99) {
        $worksheet-&gt;repeat_formula($row, 1, $formula, $format, 'A1', 'A'.($row +1));
    }
</PRE>
</P>
<P>
It should be noted that <CODE>repeat_formula()</CODE> doesn't modify the tokens. In the above example the substitution is always
made against the original token, <CODE>A1</CODE>, which doesn't change.

</P>
<P>
As usual, you can use <CODE>undef</CODE> if you don't wish to specify a <CODE>$format</CODE>:

</P>
<P>
<PRE>
    $worksheet-&gt;repeat_formula('B2', $formula, $format, 'A1', 'A2');
    $worksheet-&gt;repeat_formula('B3', $formula, undef,   'A1', 'A3');
</PRE>
</P>
<P>
The substitutions are made from left to right and you can use as many <CODE>$pattern</CODE>, <CODE>$replace</CODE> pairs as you need. However, each substitution is made only once:

</P>
<P>
<PRE>
    my $formula = $worksheet-&gt;store_formula('=A1 + A1');
</PRE>
</P>
<P>
<PRE>
    # Gives '=B1 + A1'
    $worksheet-&gt;repeat_formula('B1', $formula, undef, 'A1', 'B1');
</PRE>
</P>
<P>
<PRE>
    # Gives '=B1 + B1'
    $worksheet-&gt;repeat_formula('B2', $formula, undef, ('A1', 'B1') x 2);
</PRE>
</P>
<P>
Since the <CODE>$pattern</CODE> is interpolated each time that it is used it is worth using the <CODE>qr</CODE> operator to quote the pattern. The <CODE>qr</CODE> operator is explained in the <CODE>perlop</CODE> man page.

</P>
<P>
<PRE>
    $worksheet-&gt;repeat_formula('B1', $formula, $format, qr/A1/, 'A2');
</PRE>
</P>
<P>
Care should be taken with the values that are substituted. The formula
returned by <CODE>repeat_formula()</CODE> contains several other tokens in addition to those in the formula and these
might also match the pattern that you are trying to replace. In particular
you should avoid substituting a single 0, 1, 2 or 3.

</P>
<P>
You should also be careful to avoid false matches. For example the
following snippet is meant to change the stored formula in steps from <CODE>=A1 + SIN(A1)</CODE> to <CODE>=A10 + SIN(A10)</CODE>.

</P>
<P>
<PRE>
    my $formula = $worksheet-&gt;store_formula('=A1 + SIN(A1)');
</PRE>
</P>
<P>
<PRE>
    for my $row (1 .. 10) {
        $worksheet-&gt;repeat_formula($row -1, 1, $formula, undef,
                                    qw/A1/, 'A' . $row,   #! Bad.
                                    qw/A1/, 'A' . $row    #! Bad.
                                  );
    }
</PRE>
</P>
<P>
However it contains a bug. In the last iteration of the loop when <CODE>$row</CODE> is 10 the following substitutions will occur:

</P>
<P>
<PRE>
    s/A1/A10/;    changes    =A1 + SIN(A1)     to    =A10 + SIN(A1)
    s/A1/A10/;    changes    =A10 + SIN(A1)    to    =A100 + SIN(A1) # !!
</PRE>
</P>
<P>
The solution in this case is to use a more explicit match such as <CODE>qw/^A1$/</CODE>:

</P>
<P>
<PRE>
        $worksheet-&gt;repeat_formula($row -1, 1, $formula, undef,
                                    qw/^A1$/, 'A' . $row,
                                    qw/^A1$/, 'A' . $row
                                  );
</PRE>
</P>
<P>
Another similar problem occurs due to the fact that substitutions are made
in order. For example the following snippet is meant to change the stored
formula from <CODE>=A10 + A11</CODE>  to <CODE>=A11 + A12</CODE>:

</P>
<P>
<PRE>
    my $formula = $worksheet-&gt;store_formula('=A10 + A11');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;repeat_formula('A1', $formula, undef,
                                qw/A10/, 'A11',   #! Bad.
                                qw/A11/, 'A12'    #! Bad.
                              );
</PRE>
</P>
<P>
However, the actual substitution yields <CODE>=A12 + A11</CODE>:

</P>
<P>
<PRE>
    s/A10/A11/;    changes    =A10 + A11    to    =A11 + A11
    s/A11/A12/;    changes    =A11 + A11    to    =A12 + A11 # !!
</PRE>
</P>
<P>
The solution here would be to reverse the order of the substitutions or to
start with a stored formula that won't yield a false match such as <CODE>=X10 + Y11</CODE>:

</P>
<P>
<PRE>
    my $formula = $worksheet-&gt;store_formula('=X10 + Y11');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;repeat_formula('A1', $formula, undef,
                                qw/X10/, 'A11',
                                qw/Y11/, 'A12'
                              );
</PRE>
</P>
<P>
If you think that you have a problem related to a false match you can check
the tokens that you are substituting against as follows.

</P>
<P>
<PRE>
    my $formula = $worksheet-&gt;store_formula('=A1*5+4');
    print &quot;@$formula\n&quot;;
</PRE>
</P>
<P>
See also the <CODE>repeat.pl</CODE> program in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
<HR>
<H2><A NAME="write_comment_row_column_st">write_comment($row, $column, $string, ...)</A></H2>
<P>
The <CODE>write_comment()</CODE> method is used to add a comment to a cell. A cell comment is indicated in
Excel by a small red triangle in the upper right-hand corner of the cell.
Moving the cursor over the red triangle will reveal the comment.

</P>
<P>
The following example shows how to add a comment to a cell:

</P>
<P>
<PRE>
    $worksheet-&gt;write        (2, 2, 'Hello');
    $worksheet-&gt;write_comment(2, 2, 'This is a comment.');
</PRE>
</P>
<P>
As usual you can replace the <CODE>$row</CODE> and <CODE>$column</CODE> parameters with an <CODE>A1</CODE> cell reference. See the note about <A HREF="#Cell_notation">Cell notation</A>.

</P>
<P>
<PRE>
    $worksheet-&gt;write        ('C3', 'Hello');
    $worksheet-&gt;write_comment('C3', 'This is a comment.');
</PRE>
</P>
<P>
On systems with <CODE>perl 5.8</CODE> and later the <CODE>write_comment()</CODE> method will also handle strings in <CODE>UTF-8</CODE> format.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', &quot;\x{263a}&quot;);       # Smiley
    $worksheet-&gt;write_comment('C4', 'Comment ca va?');
</PRE>
</P>
<P>
In addition to the basic 3 argument form of <CODE>write_comment()</CODE> you can pass in several optional key/value pairs to control the format of
the comment. For example:

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', visible =&gt; 1, author =&gt; 'Perl');
</PRE>
</P>
<P>
Most of these options are quite specific and in general the default comment
behaviour will be all that you need. However, should you need greater
control over the format of the cell comment the following options are
available:

</P>
<P>
<PRE>
    encoding
    author
    author_encoding
    visible
    x_scale
    width
    y_scale
    height
    color
    start_cell
    start_row
    start_col
    x_offset
    y_offset
</PRE>
</P>
<DL>
<DT><A NAME="item_Option">Option: encoding</A><DD>
<P>
This option is used to indicate that the comment string is encoded as <CODE>UTF-16BE</CODE>.

</P>
<P>
<PRE>
    my $comment = pack 'n', 0x263a; # UTF-16BE Smiley symbol
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', $comment, encoding =&gt; 1);
</PRE>
</P>
<P>
If you wish to use Unicode characters in the comment string then the
preferred method is to use perl 5.8 and <CODE>UTF-8</CODE> strings, see <A HREF="#UNICODE_IN_EXCEL">UNICODE IN EXCEL</A>.

</P>
<DT>Option: author<DD>
<P>
This option is used to indicate who the author of the comment is. Excel
displays the author of the comment in the status bar at the bottom of the
worksheet. This is usually of interest in corporate environments where
several people might review and provide comments to a workbook.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Atonement', author =&gt; 'Ian McEwan');
</PRE>
</P>
<DT>Option: author_encoding<DD>
<P>
This option is used to indicate that the author string is encoded as <CODE>UTF-16BE</CODE>.

</P>
<DT>Option: visible<DD>
<P>
This option is used to make a cell comment visible when the worksheet is
opened. The default behaviour in Excel is that comments are initially
hidden. However, it is also possible in Excel to make individual or all
comments visible. In Spreadsheet::WriteExcel individual comments can be
made visible as follows:

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', visible =&gt; 1);
</PRE>
</P>
<P>
It is possible to make all comments in a worksheet visible using the <CODE>show_comments()</CODE> worksheet method (see below). Alternatively, if all of the cell comments
have been made visible you can hide individual comments:

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', visible =&gt; 0);
</PRE>
</P>
<DT>Option: x_scale<DD>
<P>
This option is used to set the width of the cell comment box as a factor of
the default width.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', x_scale =&gt; 2);
    $worksheet-&gt;write_comment('C4', 'Hello', x_scale =&gt; 4.2);
</PRE>
</P>
<DT>Option: width<DD>
<P>
This option is used to set the width of the cell comment box explicitly in
pixels.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', width =&gt; 200);
</PRE>
</P>
<DT>Option: y_scale<DD>
<P>
This option is used to set the height of the cell comment box as a factor
of the default height.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', y_scale =&gt; 2);
    $worksheet-&gt;write_comment('C4', 'Hello', y_scale =&gt; 4.2);
</PRE>
</P>
<DT>Option: height<DD>
<P>
This option is used to set the height of the cell comment box explicitly in
pixels.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', height =&gt; 200);
</PRE>
</P>
<DT>Option: color<DD>
<P>
This option is used to set the background colour of cell comment box. You
can use one of the named colours recognised by Spreadsheet::WriteExcel or a
colour index. See <A HREF="#COLOURS_IN_EXCEL">COLOURS IN EXCEL</A>.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', color =&gt; 'green');
    $worksheet-&gt;write_comment('C4', 'Hello', color =&gt; 0x35);    # Orange
</PRE>
</P>
<DT>Option: start_cell<DD>
<P>
This option is used to set the cell in which the comment will appear. By
default Excel displays comments one cell to the right and one cell above
the cell to which the comment relates. However, you can change this
behaviour if you wish. In the following example the comment which would
appear by default in cell <CODE>D2</CODE> is moved to <CODE>E2</CODE>.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', start_cell =&gt; 'E2');
</PRE>
</P>
<DT>Option: start_row<DD>
<P>
This option is used to set the row in which the comment will appear. See
the <CODE>start_cell</CODE> option above. The row is zero indexed.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', start_row =&gt; 0);
</PRE>
</P>
<DT>Option: start_col<DD>
<P>
This option is used to set the column in which the comment will appear. See
the <CODE>start_cell</CODE> option above. The column is zero indexed.

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', start_col =&gt; 4);
</PRE>
</P>
<DT>Option: x_offset<DD>
<P>
This option is used to change the x offset, in pixels, of a comment within
a cell:

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', $comment, x_offset =&gt; 30);
</PRE>
</P>
<DT>Option: y_offset<DD>
<P>
This option is used to change the y offset, in pixels, of a comment within
a cell:

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', $comment, x_offset =&gt; 30);
</PRE>
</P>
</DL>
<P>
You can apply as many of these options as you require.

</P>
<P>
<STRONG>Note about row height and comments</STRONG>. If you specify the height of a row that contains a comment then
Spreadsheet::WriteExcel will adjust the height of the comment to maintain
the default or user specified dimensions. However, the height of a row can
also be adjusted automatically by Excel if the text wrap property is set or
large fonts are used in the cell. This means that the height of the row is
unknown to WriteExcel at run time and thus the comment box is stretched
with the row. Use the <CODE>set_row()</CODE> method to specify the row height explicitly and avoid this problem.

</P>
<P>
<HR>
<H2><A NAME="show_comments_">show_comments()</A></H2>
<P>
This method is used to make all cell comments visible when a worksheet is
opened.

</P>
<P>
Individual comments can be made visible using the <CODE>visible</CODE> parameter of the <CODE>write_comment</CODE> method (see above):

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', visible =&gt; 1);
</PRE>
</P>
<P>
If all of the cell comments have been made visible you can hide individual
comments as follows:

</P>
<P>
<PRE>
    $worksheet-&gt;write_comment('C3', 'Hello', visible =&gt; 0);
</PRE>
</P>
<P>
<HR>
<H2><A NAME="add_write_handler_re_code_ref">add_write_handler($re, $code_ref)</A></H2>
<P>
This method is used to extend the Spreadsheet::WriteExcel
<CODE>write()</CODE> method to handle user defined data.

</P>
<P>
If you refer to the section on <CODE>write()</CODE> above you will see that it acts as an alias for several more specific <CODE>write_*</CODE> methods. However, it doesn't always act in exactly the way that you would
like it to.

</P>
<P>
One solution is to filter the input data yourself and call the appropriate <CODE>write_*</CODE> method. Another approach is to use the <CODE>add_write_handler()</CODE> method to add your own automated behaviour to <CODE>write()</CODE>.

</P>
<P>
The <CODE>add_write_handler()</CODE> method take two arguments, <CODE>$re</CODE>, a regular expression to match incoming data and <CODE>$code_ref</CODE> a callback function to handle the matched data:

</P>
<P>
<PRE>
    $worksheet-&gt;add_write_handler(qr/^\d\d\d\d$/, \&amp;my_write);
</PRE>
</P>
<P>
(In the these examples the <CODE>qr</CODE> operator is used to quote the regular expression strings, see <EM>perlop</EM> for more details).

</P>
<P>
The method is used as follows. say you wished to write 7 digit ID numbers
as a string so that any leading zeros were preserved*, you could do
something like the following:

</P>
<P>
<PRE>
    $worksheet-&gt;add_write_handler(qr/^\d{7}$/, \&amp;write_my_id);
</PRE>
</P>
<P>
<PRE>
    sub write_my_id {
        my $worksheet = shift;
        return $worksheet-&gt;write_string(@_);
    }
</PRE>
</P>
<P>
* You could also use the <CODE>keep_leading_zeros()</CODE> method for this.

</P>
<P>
Then if you call <CODE>write()</CODE> with an appropriate string it will be handled automatically:

</P>
<P>
<PRE>
    # Writes 0000000. It would normally be written as a number; 0.
    $worksheet-&gt;write('A1', '0000000');
</PRE>
</P>
<P>
The callback function will receive a reference to the calling worksheet and
all of the other arguments that were passed to <CODE>write()</CODE>. The callback will see an <CODE>@_</CODE> argument list that looks like the following:

</P>
<P>
<PRE>
    $_[0]   A ref to the calling worksheet. *
    $_[1]   Zero based row number.
    $_[2]   Zero based column number.
    $_[3]   A number or string or token.
    $_[4]   A format ref if any.
    $_[5]   Any other arguments.
    ...
</PRE>
</P>
<P>
<PRE>
    *  It is good style to shift this off the list so the @_ is the same
       as the argument list seen by write().
</PRE>
</P>
<P>
Your callback should <CODE>return()</CODE> the return value of the <CODE>write_*</CODE> method that was called or <CODE>undef</CODE> to indicate that you rejected the match and want <CODE>write()</CODE> to continue as normal.

</P>
<P>
So for example if you wished to apply the previous filter only to ID values
that occur in the first column you could modify your callback function as
follows:

</P>
<P>
<PRE>
    sub write_my_id {
        my $worksheet = shift;
        my $col       = $_[1];
</PRE>
</P>
<P>
<PRE>
        if ($col == 0) {
            return $worksheet-&gt;write_string(@_);
        }
        else {
            # Reject the match and return control to write()
            return undef;
        }
    }
</PRE>
</P>
<P>
Now, you will get different behaviour for the first column and other
columns:

</P>
<P>
<PRE>
    $worksheet-&gt;write('A1', '0000000'); # Writes 0000000
    $worksheet-&gt;write('B1', '0000000'); # Writes 0
</PRE>
</P>
<P>
You may add more than one handler in which case they will be called in the
order that they were added.

</P>
<P>
Note, the <CODE>add_write_handler()</CODE> method is particularly suited for handling dates.

</P>
<P>
See the <CODE>write_handler 1-4</CODE> programs in the <CODE>examples</CODE> directory for further examples.

</P>
<P>
<HR>
<H2><A NAME="insert_image_row_col_filena">insert_image($row, $col, $filename, $x, $y, $scale_x, $scale_y)</A></H2>
<P>
This method can be used to insert a image into a worksheet. The image can
be in PNG, JPEG or BMP format. The <CODE>$x</CODE>, <CODE>$y</CODE>, <CODE>$scale_x</CODE> and <CODE>$scale_y</CODE> parameters are optional.

</P>
<P>
<PRE>
    $worksheet1-&gt;insert_image('A1', 'perl.bmp');
    $worksheet2-&gt;insert_image('A1', '../images/perl.bmp');
    $worksheet3-&gt;insert_image('A1', '.c:\images\perl.bmp');
</PRE>
</P>
<P>
The parameters <CODE>$x</CODE> and <CODE>$y</CODE> can be used to specify an offset from the top left hand corner of the cell
specified by <CODE>$row</CODE> and <CODE>$col</CODE>. The offset values are in pixels.

</P>
<P>
<PRE>
    $worksheet1-&gt;insert_image('A1', 'perl.bmp', 32, 10);
</PRE>
</P>
<P>
The default width of a cell is 63 pixels. The default height of a cell is
17 pixels. The pixels offsets can be calculated using the following
relationships:

</P>
<P>
<PRE>
    Wp = int(12We)   if We &lt;  1
    Wp = int(7We +5) if We &gt;= 1
    Hp = int(4/3He)
</PRE>
</P>
<P>
<PRE>
    where:
    We is the cell width in Excels units
    Wp is width in pixels
    He is the cell height in Excels units
    Hp is height in pixels
</PRE>
</P>
<P>
The offsets can be greater than the width or height of the underlying cell.
This can be occasionally useful if you wish to align two or more images
relative to the same cell.

</P>
<P>
The parameters <CODE>$scale_x</CODE> and <CODE>$scale_y</CODE> can be used to scale the inserted image horizontally and vertically:

</P>
<P>
<PRE>
    # Scale the inserted image: width x 2.0, height x 0.8
    $worksheet-&gt;insert_image('A1', 'perl.bmp', 0, 0, 2, 0.8);
</PRE>
</P>
<P>
See also the <CODE>images.pl</CODE> program in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
Note: you must call <CODE>set_row()</CODE> or <CODE>set_column()</CODE> before <CODE>insert_image()</CODE> if you wish to change the default dimensions of any of the rows or columns
that the image occupies. The height of a row can also change if you use a
font that is larger than the default. This in turn will affect the scaling
of your image. To avoid this you should explicitly set the height of the
row using <CODE>set_row()</CODE> if it contains a font size that will change the row height.

</P>
<P>
BMP images must be 24 bit, true colour, bitmaps. In general it is best to
avoid BMP images since they aren't compressed. The older <CODE>insert_bitmap()</CODE> method is still supported but deprecated.

</P>
<P>
<HR>
<H2><A NAME="embed_chart_row_col_filenam">embed_chart($row, $col, $filename, $x, $y, $scale_x, $scale_y)</A></H2>
<P>
This method can be used to insert a chart into a worksheet. The chart must
first be extracted from an existing Excel file. See the separate <CODE>Charts</CODE> documentation.

</P>
<P>
Here is an example:

</P>
<P>
<PRE>
    $worksheet-&gt;embed_chart('B2', 'sales_chart.bin');
</PRE>
</P>
<P>
The <CODE>$x</CODE>, <CODE>$y</CODE>, <CODE>$scale_x</CODE> and <CODE>$scale_y</CODE> parameters are optional.

</P>
<P>
The parameters <CODE>$x</CODE> and <CODE>$y</CODE> can be used to specify an offset from the top left hand corner of the cell
specified by <CODE>$row</CODE> and <CODE>$col</CODE>. The offset values are in pixels. See the <CODE>insert_image</CODE> method above for more information on sizes.

</P>
<P>
<PRE>
    $worksheet1-&gt;embed_chart('B2', 'sales_chart.bin', 3, 3);
</PRE>
</P>
<P>
The parameters <CODE>$scale_x</CODE> and <CODE>$scale_y</CODE> can be used to scale the inserted image horizontally and vertically:

</P>
<P>
<PRE>
    # Scale the width by 120% and the height by 150%
    $worksheet-&gt;embed_chart('B2', 'sales_chart.bin', 0, 0, 1.2, 1.5);
</PRE>
</P>
<P>
The easiest way to calculate the required scaling is to create a test chart
worksheet with Spreadsheet::WriteExcel. Then open the file, select the
chart and drag the corner to get the required size. While holding down the
mouse the scale of the resized chart is shown to the left of the formula
bar.

</P>
<P>
See also the example programs in the <CODE>charts</CODE> directory of the distro.

</P>
<P>
Note: you must call <CODE>set_row()</CODE> or <CODE>set_column()</CODE> before <CODE>embed_chart()</CODE> if you wish to change the default dimensions of any of the rows or columns
that the chart occupies. The height of a row can also change if you use a
font that is larger than the default. This in turn will affect the scaling
of your chart. To avoid this you should explicitly set the height of the
row using <CODE>set_row()</CODE> if it contains a font size that will change the row height.

</P>
<P>
<HR>
<H2><A NAME="get_name_">get_name()</A></H2>
<P>
The <CODE>get_name()</CODE> method is used to retrieve the name of a worksheet. For example:

</P>
<P>
<PRE>
    foreach my $sheet ($workbook-&gt;sheets()) {
        print $sheet-&gt;get_name();
    }
</PRE>
</P>
<P>
For reasons related to the design of Spreadsheet::WriteExcel and to the
internals of Excel there is no <CODE>set_name()</CODE> method. The only way to set the worksheet name is via the <CODE>add_worksheet()</CODE> method.

</P>
<P>
<HR>
<H2><A NAME="activate_">activate()</A></H2>
<P>
The <CODE>activate()</CODE> method is used to specify which worksheet is initially visible in a
multi-sheet workbook:

</P>
<P>
<PRE>
    $worksheet1 = $workbook-&gt;add_worksheet('To');
    $worksheet2 = $workbook-&gt;add_worksheet('the');
    $worksheet3 = $workbook-&gt;add_worksheet('wind');
</PRE>
</P>
<P>
<PRE>
    $worksheet3-&gt;activate();
</PRE>
</P>
<P>
This is similar to the Excel VBA activate method. More than one worksheet
can be selected via the <CODE>select()</CODE> method, see below, however only one worksheet can be active.

</P>
<P>
The default active worksheet is the first worksheet.

</P>
<P>
<HR>
<H2><A NAME="select_">select()</A></H2>
<P>
The <CODE>select()</CODE> method is used to indicate that a worksheet is selected in a multi-sheet
workbook:

</P>
<P>
<PRE>
    $worksheet1-&gt;activate();
    $worksheet2-&gt;select();
    $worksheet3-&gt;select();
</PRE>
</P>
<P>
A selected worksheet has its tab highlighted. Selecting worksheets is a way
of grouping them together so that, for example, several worksheets could be
printed in one go. A worksheet that has been activated via the <CODE>activate()</CODE> method will also appear as selected.

</P>
<P>
<HR>
<H2><A NAME="hide_">hide()</A></H2>
<P>
The <CODE>hide()</CODE> method is used to hide a worksheet:

</P>
<P>
<PRE>
    $worksheet2-&gt;hide();
</PRE>
</P>
<P>
You may wish to hide a worksheet in order to avoid confusing a user with
intermediate data or calculations.

</P>
<P>
A hidden worksheet can not be activated or selected so this method is
mutually exclusive with the <CODE>activate()</CODE> and <CODE>select()</CODE> methods. In addition, since the first worksheet will default to being the
active worksheet, you cannot hide the first worksheet without activating
another sheet:

</P>
<P>
<PRE>
    $worksheet2-&gt;activate();
    $worksheet1-&gt;hide();
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_first_sheet_">set_first_sheet()</A></H2>
<P>
The <CODE>activate()</CODE> method determines which worksheet is initially selected. However, if there
are a large number of worksheets the selected worksheet may not appear on
the screen. To avoid this you can select which is the leftmost visible
worksheet using <CODE>set_first_sheet()</CODE>:

</P>
<P>
<PRE>
    for (1..20) {
        $workbook-&gt;add_worksheet;
    }
</PRE>
</P>
<P>
<PRE>
    $worksheet21 = $workbook-&gt;add_worksheet();
    $worksheet22 = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    $worksheet21-&gt;set_first_sheet();
    $worksheet22-&gt;activate();
</PRE>
</P>
<P>
This method is not required very often. The default value is the first
worksheet.

</P>
<P>
<HR>
<H2><A NAME="protect_password_">protect($password)</A></H2>
<P>
The <CODE>protect()</CODE> method is used to protect a worksheet from modification:

</P>
<P>
<PRE>
    $worksheet-&gt;protect();
</PRE>
</P>
<P>
It can be turned off in Excel via the <CODE>Tools-&gt;Protection-&gt;Unprotect Sheet</CODE> menu command.

</P>
<P>
The <CODE>protect()</CODE> method also has the effect of enabling a cell's <CODE>locked</CODE> and <CODE>hidden</CODE> properties if they have been set. A "locked" cell cannot be edited. A
"hidden" cell will display the results of a formula but not the formula
itself. In Excel a cell's locked property is on by default.

</P>
<P>
<PRE>
    # Set some format properties
    my $unlocked  = $workbook-&gt;add_format(locked =&gt; 0);
    my $hidden    = $workbook-&gt;add_format(hidden =&gt; 1);
</PRE>
</P>
<P>
<PRE>
    # Enable worksheet protection
    $worksheet-&gt;protect();
</PRE>
</P>
<P>
<PRE>
    # This cell cannot be edited, it is locked by default
    $worksheet-&gt;write('A1', '=1+2');
</PRE>
</P>
<P>
<PRE>
    # This cell can be edited
    $worksheet-&gt;write('A2', '=1+2', $unlocked);
</PRE>
</P>
<P>
<PRE>
    # The formula in this cell isn't visible
    $worksheet-&gt;write('A3', '=1+2', $hidden);
</PRE>
</P>
<P>
See also the <CODE>set_locked</CODE> and <CODE>set_hidden</CODE> format methods in <A HREF="#CELL_FORMATTING">CELL FORMATTING</A>.

</P>
<P>
You can optionally add a password to the worksheet protection:

</P>
<P>
<PRE>
    $worksheet-&gt;protect('drowssap');
</PRE>
</P>
<P>
Note, the worksheet level password in Excel provides very weak protection.
It does not encrypt your data in any way and it is very easy to deactivate.
Therefore, do not use the above method if you wish to protect sensitive
data or calculations. However, before you get worried, Excel's own workbook
level password protection does provide strong encryption in Excel 97+. For
technical reasons this will never be supported by <CODE>Spreadsheet::WriteExcel</CODE>.

</P>
<P>
<HR>
<H2><A NAME="set_selection_first_row_first">set_selection($first_row, $first_col, $last_row, $last_col)</A></H2>
<P>
This method can be used to specify which cell or cells are selected in a
worksheet. The most common requirement is to select a single cell, in which
case <CODE>$last_row</CODE> and <CODE>$last_col</CODE> can be omitted. The active cell within a selected range is determined by
the order in which <CODE>$first</CODE> and <CODE>$last</CODE> are specified. It is also possible to specify a cell or a range using A1
notation. See the note about <A HREF="#Cell_notation">Cell notation</A>.

</P>
<P>
Examples:

</P>
<P>
<PRE>
    $worksheet1-&gt;set_selection(3, 3);       # 1. Cell D4.
    $worksheet2-&gt;set_selection(3, 3, 6, 6); # 2. Cells D4 to G7.
    $worksheet3-&gt;set_selection(6, 6, 3, 3); # 3. Cells G7 to D4.
    $worksheet4-&gt;set_selection('D4');       # Same as 1.
    $worksheet5-&gt;set_selection('D4:G7');    # Same as 2.
    $worksheet6-&gt;set_selection('G7:D4');    # Same as 3.
</PRE>
</P>
<P>
The default cell selections is (0, 0), 'A1'.

</P>
<P>
<HR>
<H2><A NAME="set_row_row_height_format_">set_row($row, $height, $format, $hidden, $level, $collapsed)</A></H2>
<P>
This method can be used to change the default properties of a row. All
parameters apart from <CODE>$row</CODE> are optional.

</P>
<P>
The most common use for this method is to change the height of a row:

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(0, 20); # Row 1 height set to 20
</PRE>
</P>
<P>
If you wish to set the format without changing the height you can pass <CODE>undef</CODE> as the height parameter:

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(0, undef, $format);
</PRE>
</P>
<P>
The <CODE>$format</CODE> parameter will be applied to any cells in the row that don't have a format.
For example

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(0, undef, $format1);    # Set the format for row 1
    $worksheet-&gt;write('A1', 'Hello');           # Defaults to $format1
    $worksheet-&gt;write('B1', 'Hello', $format2); # Keeps $format2
</PRE>
</P>
<P>
If you wish to define a row format in this way you should call the method
before any calls to <CODE>write()</CODE>. Calling it afterwards will overwrite any format that was previously
specified.

</P>
<P>
The <CODE>$hidden</CODE> parameter should be set to 1 if you wish to hide a row. This can be used,
for example, to hide intermediary steps in a complicated calculation:

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(0, 20,    $format, 1);
    $worksheet-&gt;set_row(1, undef, undef,   1);
</PRE>
</P>
<P>
The <CODE>$level</CODE> parameter is used to set the outline level of the row. Outlines are
described in <A HREF="#OUTLINES_AND_GROUPING_IN_EXCEL">OUTLINES AND GROUPING IN EXCEL</A>. Adjacent rows with the same outline level are grouped together into a
single outline.

</P>
<P>
The following example sets an outline level of 1 for rows 1 and 2
(zero-indexed):

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(1, undef, undef, 0, 1);
    $worksheet-&gt;set_row(2, undef, undef, 0, 1);
</PRE>
</P>
<P>
The <CODE>$hidden</CODE> parameter can also be used to hide collapsed outlined rows when used in
conjunction with the <CODE>$level</CODE> parameter.

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(1, undef, undef, 1, 1);
    $worksheet-&gt;set_row(2, undef, undef, 1, 1);
</PRE>
</P>
<P>
For collapsed outlines you should also indicate which row has the collapsed <CODE>+</CODE> symbol using the optional <CODE>$collapsed</CODE> parameter.

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(3, undef, undef, 0, 0, 1);
</PRE>
</P>
<P>
For a more complete example see the <CODE>outline.pl</CODE> and <CODE>outline_collapsed.pl</CODE> programs in the examples directory of the distro.

</P>
<P>
Excel allows up to 7 outline levels. Therefore the <CODE>$level</CODE> parameter should be in the range <CODE>0 &lt;= $level &lt;= 7</CODE>.

</P>
<P>
<HR>
<H2><A NAME="set_column_first_col_last_col">set_column($first_col, $last_col, $width, $format, $hidden, $level, $collapsed)</A></H2>
<P>
This method can be used to change the default properties of a single column
or a range of columns. All parameters apart from <CODE>$first_col</CODE> and <CODE>$last_col</CODE> are optional.

</P>
<P>
If <CODE>set_column()</CODE> is applied to a single column the value of <CODE>$first_col</CODE> and <CODE>$last_col</CODE> should be the same. In the case where <CODE>$last_col</CODE> is zero it is set to the same value as <CODE>$first_col</CODE>.

</P>
<P>
It is also possible, and generally clearer, to specify a column range using
the form of A1 notation used for columns. See the note about <A HREF="#Cell_notation">Cell notation</A>.

</P>
<P>
Examples:

</P>
<P>
<PRE>
    $worksheet-&gt;set_column(0, 0,  20); # Column  A   width set to 20
    $worksheet-&gt;set_column(1, 3,  30); # Columns B-D width set to 30
    $worksheet-&gt;set_column('E:E', 20); # Column  E   width set to 20
    $worksheet-&gt;set_column('F:H', 30); # Columns F-H width set to 30
</PRE>
</P>
<P>
The width corresponds to the column width value that is specified in Excel.
It is approximately equal to the length of a string in the default font of
Arial 10. Unfortunately, there is no way to specify "AutoFit" for a column
in the Excel file format. This feature is only available at runtime from
within Excel.

</P>
<P>
As usual the <CODE>$format</CODE> parameter is optional, for additional information, see <A HREF="#CELL_FORMATTING">CELL FORMATTING</A>. If you wish to set the format without changing the width you can pass <CODE>undef</CODE> as the width parameter:

</P>
<P>
<PRE>
    $worksheet-&gt;set_column(0, 0, undef, $format);
</PRE>
</P>
<P>
The <CODE>$format</CODE> parameter will be applied to any cells in the column that don't have a
format. For example

</P>
<P>
<PRE>
    $worksheet-&gt;set_column('A:A', undef, $format1); # Set format for col 1
    $worksheet-&gt;write('A1', 'Hello');               # Defaults to $format1
    $worksheet-&gt;write('A2', 'Hello', $format2);     # Keeps $format2
</PRE>
</P>
<P>
If you wish to define a column format in this way you should call the
method before any calls to <CODE>write()</CODE>. If you call it afterwards it won't have any effect.

</P>
<P>
A default row format takes precedence over a default column format

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(0, undef,        $format1); # Set format for row 1
    $worksheet-&gt;set_column('A:A', undef, $format2); # Set format for col 1
    $worksheet-&gt;write('A1', 'Hello');               # Defaults to $format1
    $worksheet-&gt;write('A2', 'Hello');               # Defaults to $format2
</PRE>
</P>
<P>
The <CODE>$hidden</CODE> parameter should be set to 1 if you wish to hide a column. This can be
used, for example, to hide intermediary steps in a complicated calculation:

</P>
<P>
<PRE>
    $worksheet-&gt;set_column('D:D', 20,    $format, 1);
    $worksheet-&gt;set_column('E:E', undef, undef,   1);
</PRE>
</P>
<P>
The <CODE>$level</CODE> parameter is used to set the outline level of the column. Outlines are
described in <A HREF="#OUTLINES_AND_GROUPING_IN_EXCEL">OUTLINES AND GROUPING IN EXCEL</A>. Adjacent columns with the same outline level are grouped together into a
single outline.

</P>
<P>
The following example sets an outline level of 1 for columns B to G:

</P>
<P>
<PRE>
    $worksheet-&gt;set_column('B:G', undef, undef, 0, 1);
</PRE>
</P>
<P>
The <CODE>$hidden</CODE> parameter can also be used to hide collapsed outlined columns when used in
conjunction with the <CODE>$level</CODE> parameter.

</P>
<P>
<PRE>
    $worksheet-&gt;set_column('B:G', undef, undef, 1, 1);
</PRE>
</P>
<P>
For collapsed outlines you should also indicate which row has the collapsed <CODE>+</CODE> symbol using the optional <CODE>$collapsed</CODE> parameter.

</P>
<P>
<PRE>
    $worksheet-&gt;set_column('H:H', undef, undef, 0, 0, 1);
</PRE>
</P>
<P>
For a more complete example see the <CODE>outline.pl</CODE> and <CODE>outline_collapsed.pl</CODE> programs in the examples directory of the distro.

</P>
<P>
Excel allows up to 7 outline levels. Therefore the <CODE>$level</CODE> parameter should be in the range <CODE>0 &lt;= $level &lt;= 7</CODE>.

</P>
<P>
<HR>
<H2><A NAME="outline_settings_visible_symb">outline_settings($visible, $symbols_below, $symbols_right, $auto_style)</A></H2>
<P>
The <CODE>outline_settings()</CODE> method is used to control the appearance of outlines in Excel. Outlines are
described in <A HREF="#OUTLINES_AND_GROUPING_IN_EXCEL">OUTLINES AND GROUPING IN EXCEL</A>.

</P>
<P>
The <CODE>$visible</CODE> parameter is used to control whether or not outlines are visible. Setting
this parameter to 0 will cause all outlines on the worksheet to be hidden.
They can be unhidden in Excel by means of the "Show Outline Symbols"
command button. The default setting is 1 for visible outlines.

</P>
<P>
<PRE>
    $worksheet-&gt;outline_settings(0);
</PRE>
</P>
<P>
The <CODE>$symbols_below</CODE> parameter is used to control whether the row outline symbol will appear
above or below the outline level bar. The default setting is 1 for symbols
to appear below the outline level bar.

</P>
<P>
The <CODE>symbols_right</CODE> parameter is used to control whether the column outline symbol will appear
to the left or the right of the outline level bar. The default setting is 1
for symbols to appear to the right of the outline level bar.

</P>
<P>
The <CODE>$auto_style</CODE> parameter is used to control whether the automatic outline generator in
Excel uses automatic styles when creating an outline. This has no effect on
a file generated by <CODE>Spreadsheet::WriteExcel</CODE> but it does have an effect on how the worksheet behaves after it is
created. The default setting is 0 for "Automatic Styles" to be turned off.

</P>
<P>
The default settings for all of these parameters correspond to Excel's
default parameters.

</P>
<P>
The worksheet parameters controlled by <CODE>outline_settings()</CODE> are rarely used.

</P>
<P>
<HR>
<H2><A NAME="freeze_panes_row_col_top_ro">freeze_panes($row, $col, $top_row, $left_col)</A></H2>
<P>
This method can be used to divide a worksheet into horizontal or vertical
regions known as panes and to also "freeze" these panes so that the
splitter bars are not visible. This is the same as the <CODE>Window-&gt;Freeze Panes</CODE> menu command in Excel

</P>
<P>
The parameters <CODE>$row</CODE> and <CODE>$col</CODE> are used to specify the location of the split. It should be noted that the
split is specified at the top or left of a cell and that the method uses
zero based indexing. Therefore to freeze the first row of a worksheet it is
necessary to specify the split at row 2 (which is 1 as the zero-based
index). This might lead you to think that you are using a 1 based index but
this is not the case.

</P>
<P>
You can set one of the <CODE>$row</CODE> and <CODE>$col</CODE> parameters as zero if you do not want either a vertical or horizontal
split.

</P>
<P>
Examples:

</P>
<P>
<PRE>
    $worksheet-&gt;freeze_panes(1, 0); # Freeze the first row
    $worksheet-&gt;freeze_panes('A2'); # Same using A1 notation
    $worksheet-&gt;freeze_panes(0, 1); # Freeze the first column
    $worksheet-&gt;freeze_panes('B1'); # Same using A1 notation
    $worksheet-&gt;freeze_panes(1, 2); # Freeze first row and first 2 columns
    $worksheet-&gt;freeze_panes('C2'); # Same using A1 notation
</PRE>
</P>
<P>
The parameters <CODE>$top_row</CODE> and <CODE>$left_col</CODE> are optional. They are used to specify the top-most or left-most visible
row or column in the scrolling region of the panes. For example to freeze
the first row and to have the scrolling region begin at row twenty:

</P>
<P>
<PRE>
    $worksheet-&gt;freeze_panes(1, 0, 20, 0);
</PRE>
</P>
<P>
You cannot use A1 notation for the <CODE>$top_row</CODE> and <CODE>$left_col</CODE> parameters.

</P>
<P>
See also the <CODE>panes.pl</CODE> program in the <CODE>examples</CODE> directory of the distribution.

</P>
<P>
<HR>
<H2><A NAME="split_panes_y_x_top_row_l">split_panes($y, $x, $top_row, $left_col)</A></H2>
<P>
This method can be used to divide a worksheet into horizontal or vertical
regions known as panes. This method is different from the <CODE>freeze_panes()</CODE> method in that the splits between the panes will be visible to the user and
each pane will have its own scroll bars.

</P>
<P>
The parameters <CODE>$y</CODE> and <CODE>$x</CODE> are used to specify the vertical and horizontal position of the split. The
units for <CODE>$y</CODE> and <CODE>$x</CODE> are the same as those used by Excel to specify row height and column width.
However, the vertical and horizontal units are different from each other.
Therefore you must specify the <CODE>$y</CODE> and <CODE>$x</CODE> parameters in terms of the row heights and column widths that you have set
or the default values which are <CODE>12.75</CODE> for a row and  <CODE>8.43</CODE> for a column.

</P>
<P>
You can set one of the <CODE>$y</CODE> and <CODE>$x</CODE> parameters as zero if you do not want either a vertical or horizontal
split. The parameters <CODE>$top_row</CODE> and <CODE>$left_col</CODE> are optional. They are used to specify the top-most or left-most visible
row or column in the bottom-right pane.

</P>
<P>
Example:

</P>
<P>
<PRE>
    $worksheet-&gt;split_panes(12.75, 0,    1, 0); # First row
    $worksheet-&gt;split_panes(0,     8.43, 0, 1); # First column
    $worksheet-&gt;split_panes(12.75, 8.43, 1, 1); # First row and column
</PRE>
</P>
<P>
You cannot use A1 notation with this method.

</P>
<P>
See also the <CODE>freeze_panes()</CODE> method and the <CODE>panes.pl</CODE> program in the <CODE>examples</CODE> directory of the distribution.

</P>
<P>
Note: This <CODE>split_panes()</CODE> method was called <CODE>thaw_panes()</CODE> in older versions. The older name is still available for backwards
compatiblity.

</P>
<P>
<HR>
<H2><A NAME="merge_range_first_row_first_c">merge_range($first_row, $first_col, $last_row, $last_col, $token, $format, $utf_16_be)</A></H2>
<P>
Merging cells can be achieved by setting the <CODE>merge</CODE> property of a Format object, see <A HREF="#CELL_FORMATTING">CELL FORMATTING</A>. However, this only allows simple Excel5 style horizontal merging which
Excel refers to as "center across selection".

</P>
<P>
The <CODE>merge_range()</CODE> method allows you to do Excel97+ style formatting where the cells can
contain other types of alignment in addition to the merging:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format(
                                        border  =&gt; 6,
                                        valign  =&gt; 'vcenter',
                                        align   =&gt; 'center',
                                      );
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;merge_range('B3:D4', 'Vertical and horizontal', $format);
</PRE>
</P>
<P>
<STRONG>WARNING</STRONG>. The format object that is used with a <CODE>merge_range()</CODE> method call is marked internally as being associated with a merged range.
It is a fatal error to use a merged format in a non-merged cell. Instead
you should use separate formats for merged and non-merged cells. This
restriction will be removed in a future release.

</P>
<P>
The <CODE>$utf_16_be</CODE> parameter is optional, see below.

</P>
<P>
<CODE>merge_range()</CODE> writes its <CODE>$token</CODE> argument using the worksheet <CODE>write()</CODE> method. Therefore it will handle numbers, strings, formulas or urls as
required.

</P>
<P>
Setting the <CODE>merge</CODE> property of the format isn't required when you are using <CODE>merge_range()</CODE>. In fact using it will exclude the use of any other horizontal alignment
option.

</P>
<P>
On systems with <CODE>perl 5.8</CODE> and later the <CODE>merge_range()</CODE> method will also handle strings in <CODE>UTF-8</CODE> format.

</P>
<P>
<PRE>
    $worksheet-&gt;merge_range('B3:D4', &quot;\x{263a}&quot;, $format); # Smiley
</PRE>
</P>
<P>
On earlier Perl systems your can specify <CODE>UTF-16BE</CODE> worksheet names using an additional optional parameter:

</P>
<P>
<PRE>
    my $str = pack 'n', 0x263a;
    $worksheet-&gt;merge_range('B3:D4', $str, $format, 1); # Smiley
</PRE>
</P>
<P>
The full possibilities of this method are shown in the <CODE>merge3.pl</CODE> to <CODE>merge6.pl</CODE> programs in the <CODE>examples</CODE> directory of the distribution.

</P>
<P>
<HR>
<H2><A NAME="set_zoom_scale_">set_zoom($scale)</A></H2>
<P>
Set the worksheet zoom factor in the range <CODE>10 &lt;= $scale &lt;= 400</CODE>:

</P>
<P>
<PRE>
    $worksheet1-&gt;set_zoom(50);
    $worksheet2-&gt;set_zoom(75);
    $worksheet3-&gt;set_zoom(300);
    $worksheet4-&gt;set_zoom(400);
</PRE>
</P>
<P>
The default zoom factor is 100. You cannot zoom to "Selection" because it
is calculated by Excel at run-time.

</P>
<P>
Note, <CODE>set_zoom()</CODE> does not affect the scale of the printed page. For that you should use <CODE>set_print_scale()</CODE>.

</P>
<P>
<HR>
<H2><A NAME="right_to_left_">right_to_left()</A></H2>
<P>
The <CODE>right_to_left()</CODE> method is used to change the default direction of the worksheet from
left-to-right, with the A1 cell in the top left, to right-to-left, with the
he A1 cell in the top right.

</P>
<P>
<PRE>
    $worksheet-&gt;right_to_left();
</PRE>
</P>
<P>
This is useful when creating Arabic, Hebrew or other near or far eastern
worksheets that use right-to-left as the default direction.

</P>
<P>
<HR>
<H2><A NAME="hide_zero_">hide_zero()</A></H2>
<P>
The <CODE>hide_zero()</CODE> method is used to hide any zero values that appear in cells.

</P>
<P>
<PRE>
    $worksheet-&gt;hide_zero();
</PRE>
</P>
<P>
In Excel this option is found under Tools->Options->View.

</P>
<P>
<HR>
<H2><A NAME="set_tab_color_">set_tab_color()</A></H2>
<P>
The <CODE>set_tab_color()</CODE> method is used to change the colour of the worksheet tab. This feature is
only available in Excel 2002 and later. You can use one of the standard
colour names provided by the Format object or a colour index. See <A HREF="#COLOURS_IN_EXCEL">COLOURS IN EXCEL</A> and the <CODE>set_custom_color()</CODE> method.

</P>
<P>
<PRE>
    $worksheet1-&gt;set_tab_color('red');
    $worksheet2-&gt;set_tab_color(0x0C);
</PRE>
</P>
<P>
See the <CODE>tab_colors.pl</CODE> program in the examples directory of the distro.

</P>
<P>
<HR>
<H2><A NAME="autofilter_first_row_first_co">autofilter($first_row, $first_col, $last_row, $last_col)</A></H2>
<P>
This method allows an autofilter to be added to a worksheet. An autofilter
is a way of adding drop down lists to the headers of a 2D range of
worksheet data. This is turn allow users to filter the data based on simple
criteria so that some data is highlighted and some is hidden.

</P>
<P>
To add an autofilter to a worksheet:

</P>
<P>
<PRE>
    $worksheet-&gt;autofilter(0, 0, 10, 3);
    $worksheet-&gt;autofilter('A1:D11');    # Same as above in A1 notation.
</PRE>
</P>
<P>
Filter conditions can be applied using the <CODE>filter_column()</CODE> method.

</P>
<P>
See the <CODE>autofilter.pl</CODE> program in the examples directory of the distro for a more detailed
example.

</P>
<P>
<HR>
<H2><A NAME="filter_column_column_expressi">filter_column($column, $expression)</A></H2>
<P>
The <CODE>filter_column</CODE> method can be used to filter columns in a autofilter range based on simple
conditions.

</P>
<P>
<STRONG>NOTE:</STRONG> It isn't sufficient to just specify the filter condition. You must also
hide any rows that don't match the filter condition. Rows are hidden using
the <CODE>set_row()</CODE>  <CODE>visible</CODE> parameter. <CODE>Spreadsheet::WriteExcel</CODE> cannot do this automatically since it isn't part of the file format. See
the <CODE>autofilter.pl</CODE> program in the examples directory of the distro for an example.

</P>
<P>
The conditions for the filter are specified using simple expressions:

</P>
<P>
<PRE>
    $worksheet-&gt;filter_column('A', 'x &gt; 2000');
    $worksheet-&gt;filter_column('B', 'x &gt; 2000 and x &lt; 5000');
</PRE>
</P>
<P>
The <CODE>$column</CODE> parameter can either be a zero indexed column number or a string column
name.

</P>
<P>
The following operators are available:

</P>
<P>
<PRE>
    Operator        Synonyms
       ==           =   eq  =~
       !=           &lt;&gt;  ne  !=
       &gt;
       &lt;
       &gt;=
       &lt;=
</PRE>
</P>
<P>
<PRE>
       and          &amp;&amp;
       or           ||
</PRE>
</P>
<P>
The operator synonyms are just syntactic sugar to make you more comfortable
using the expressions. It is important to remember that the expressions
will be interpreted by Excel and not by perl.

</P>
<P>
An expression can comprise a single statement or two statements separated
by the <CODE>and</CODE> and <CODE>or</CODE> operators. For example:

</P>
<P>
<PRE>
    'x &lt;  2000'
    'x &gt;  2000'
    'x == 2000'
    'x &gt;  2000 and x &lt;  5000'
    'x == 2000 or  x == 5000'
</PRE>
</P>
<P>
Filtering of blank or non-blank data can be achieved by using a value of <CODE>Blanks</CODE> or <CODE>NonBlanks</CODE> in the expression:

</P>
<P>
<PRE>
    'x == Blanks'
    'x == NonBlanks'
</PRE>
</P>
<P>
Top 10 style filters can be specified using a expression like the
following:

</P>
<P>
<PRE>
    Top|Bottom 1-500 Items|%
</PRE>
</P>
<P>
For example:

</P>
<P>
<PRE>
    'Top    10 Items'
    'Bottom  5 Items'
    'Top    25 %'
    'Bottom 50 %'
</PRE>
</P>
<P>
Excel also allows some simple string matching operations:

</P>
<P>
<PRE>
    'x =~ b*'   # begins with b
    'x !~ b*'   # doesn't begin with b
    'x =~ *b'   # ends with b
    'x !~ *b'   # doesn't end with b
    'x =~ *b*'  # contains b
    'x !~ *b*'  # doesn't contains b
</PRE>
</P>
<P>
You can also use <CODE>*</CODE> to match any character or number and <CODE>?</CODE> to match any single character or number. No other regular expression
quantifier is supported by Excel's filters. Excel's regular expression
characters can be escaped using <CODE>~</CODE>.

</P>
<P>
The placeholder variable <CODE>x</CODE> in the above examples can be replaced by any simple string. The actual
placeholder name is ignored internally so the following are all equivalent:

</P>
<P>
<PRE>
    'x     &lt; 2000'
    'col   &lt; 2000'
    'Price &lt; 2000'
</PRE>
</P>
<P>
Also, note that a filter condition can only be applied to a column in a
range specified by the <CODE>autofilter()</CODE> Worksheet method.

</P>
<P>
See the <CODE>autofilter.pl</CODE> program in the examples directory of the distro for a more detailed
example.

</P>
<P>
<HR>
<H1><A NAME="PAGE_SET_UP_METHODS">PAGE SET-UP METHODS</A></H1>
<P>
Page set-up methods affect the way that a worksheet looks when it is
printed. They control features such as page headers and footers and
margins. These methods are really just standard worksheet methods. They are
documented here in a separate section for the sake of clarity.

</P>
<P>
The following methods are available for page set-up:

</P>
<P>
<PRE>
    set_landscape()
    set_portrait()
    set_page_view()
    set_paper()
    center_horizontally()
    center_vertically()
    set_margins()
    set_header()
    set_footer()
    repeat_rows()
    repeat_columns()
    hide_gridlines()
    print_row_col_headers()
    print_area()
    print_across()
    fit_to_pages()
    set_start_page()
    set_print_scale()
    set_h_pagebreaks()
    set_v_pagebreaks()
</PRE>
</P>
<P>
A common requirement when working with Spreadsheet::WriteExcel is to apply
the same page set-up features to all of the worksheets in a workbook. To do
this you can use the <CODE>sheets()</CODE> method of the <CODE>workbook</CODE> class to access the array of worksheets in a workbook:

</P>
<P>
<PRE>
    foreach $worksheet ($workbook-&gt;sheets()) {
       $worksheet-&gt;set_landscape();
    }
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_landscape_">set_landscape()</A></H2>
<P>
This method is used to set the orientation of a worksheet's printed page to
landscape:

</P>
<P>
<PRE>
    $worksheet-&gt;set_landscape(); # Landscape mode
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_portrait_">set_portrait()</A></H2>
<P>
This method is used to set the orientation of a worksheet's printed page to
portrait. The default worksheet orientation is portrait, so you won't
generally need to call this method.

</P>
<P>
<PRE>
    $worksheet-&gt;set_portrait(); # Portrait mode
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_page_view_">set_page_view()</A></H2>
<P>
This method is used to display the worksheet in "Page View" mode. This is
currently only supported by Mac Excel, where it is the default.

</P>
<P>
<PRE>
    $worksheet-&gt;set_page_view();
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_paper_index_">set_paper($index)</A></H2>
<P>
This method is used to set the paper format for the printed output of a
worksheet. The following paper styles are available:

</P>
<P>
<PRE>
    Index   Paper format            Paper size
    =====   ============            ==========
      0     Printer default         -
      1     Letter                  8 1/2 x 11 in
      2     Letter Small            8 1/2 x 11 in
      3     Tabloid                 11 x 17 in
      4     Ledger                  17 x 11 in
      5     Legal                   8 1/2 x 14 in
      6     Statement               5 1/2 x 8 1/2 in
      7     Executive               7 1/4 x 10 1/2 in
      8     A3                      297 x 420 mm
      9     A4                      210 x 297 mm
     10     A4 Small                210 x 297 mm
     11     A5                      148 x 210 mm
     12     B4                      250 x 354 mm
     13     B5                      182 x 257 mm
     14     Folio                   8 1/2 x 13 in
     15     Quarto                  215 x 275 mm
     16     -                       10x14 in
     17     -                       11x17 in
     18     Note                    8 1/2 x 11 in
     19     Envelope  9             3 7/8 x 8 7/8
     20     Envelope 10             4 1/8 x 9 1/2
     21     Envelope 11             4 1/2 x 10 3/8
     22     Envelope 12             4 3/4 x 11
     23     Envelope 14             5 x 11 1/2
     24     C size sheet            -
     25     D size sheet            -
     26     E size sheet            -
     27     Envelope DL             110 x 220 mm
     28     Envelope C3             324 x 458 mm
     29     Envelope C4             229 x 324 mm
     30     Envelope C5             162 x 229 mm
     31     Envelope C6             114 x 162 mm
     32     Envelope C65            114 x 229 mm
     33     Envelope B4             250 x 353 mm
     34     Envelope B5             176 x 250 mm
     35     Envelope B6             176 x 125 mm
     36     Envelope                110 x 230 mm
     37     Monarch                 3.875 x 7.5 in
     38     Envelope                3 5/8 x 6 1/2 in
     39     Fanfold                 14 7/8 x 11 in
     40     German Std Fanfold      8 1/2 x 12 in
     41     German Legal Fanfold    8 1/2 x 13 in
</PRE>
</P>
<P>
Note, it is likely that not all of these paper types will be available to
the end user since it will depend on the paper formats that the user's
printer supports. Therefore, it is best to stick to standard paper types.

</P>
<P>
<PRE>
    $worksheet-&gt;set_paper(1); # US Letter
    $worksheet-&gt;set_paper(9); # A4
</PRE>
</P>
<P>
If you do not specify a paper type the worksheet will print using the
printer's default paper.

</P>
<P>
<HR>
<H2><A NAME="center_horizontally_">center_horizontally()</A></H2>
<P>
Center the worksheet data horizontally between the margins on the printed
page:

</P>
<P>
<PRE>
    $worksheet-&gt;center_horizontally();
</PRE>
</P>
<P>
<HR>
<H2><A NAME="center_vertically_">center_vertically()</A></H2>
<P>
Center the worksheet data vertically between the margins on the printed
page:

</P>
<P>
<PRE>
    $worksheet-&gt;center_vertically();
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_margins_inches_">set_margins($inches)</A></H2>
<P>
There are several methods available for setting the worksheet margins on
the printed page:

</P>
<P>
<PRE>
    set_margins()        # Set all margins to the same value
    set_margins_LR()     # Set left and right margins to the same value
    set_margins_TB()     # Set top and bottom margins to the same value
    set_margin_left();   # Set left margin
    set_margin_right();  # Set right margin
    set_margin_top();    # Set top margin
    set_margin_bottom(); # Set bottom margin
</PRE>
</P>
<P>
All of these methods take a distance in inches as a parameter. Note: 1 inch
= 25.4mm. ;-) The default left and right margin is 0.75 inch. The default
top and bottom margin is 1.00 inch.

</P>
<P>
<HR>
<H2><A NAME="set_header_string_margin_">set_header($string, $margin)</A></H2>
<P>
Headers and footers are generated using a <CODE>$string</CODE> which is a combination of plain text and control characters. The <CODE>$margin</CODE> parameter is optional.

</P>
<P>
The available control character are:

</P>
<P>
<PRE>
    Control             Category            Description
    =======             ========            ===========
    &amp;L                  Justification       Left
    &amp;C                                      Center
    &amp;R                                      Right
</PRE>
</P>
<P>
<PRE>
    &amp;P                  Information         Page number
    &amp;N                                      Total number of pages
    &amp;D                                      Date
    &amp;T                                      Time
    &amp;F                                      File name
    &amp;A                                      Worksheet name
    &amp;Z                                      Workbook path
</PRE>
</P>
<P>
<PRE>
    &amp;fontsize           Font                Font size
    &amp;&quot;font,style&quot;                           Font name and style
    &amp;U                                      Single underline
    &amp;E                                      Double underline
    &amp;S                                      Strikethrough
    &amp;X                                      Superscript
    &amp;Y                                      Subscript
</PRE>
</P>
<P>
<PRE>
    &amp;&amp;                  Miscellaneous       Literal ampersand &amp;
</PRE>
</P>
<P>
Text in headers and footers can be justified (aligned) to the left, center
and right by prefixing the text with the control characters <CODE>&amp;L</CODE>, <CODE>&amp;C</CODE> and <CODE>&amp;R</CODE>.

</P>
<P>
For example (with ASCII art representation of the results):

</P>
<P>
<PRE>
    $worksheet-&gt;set_header('&amp;LHello');
</PRE>
</P>
<P>
<PRE>
     ---------------------------------------------------------------
    |                                                               |
    | Hello                                                         |
    |                                                               |
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;set_header('&amp;CHello');
</PRE>
</P>
<P>
<PRE>
     ---------------------------------------------------------------
    |                                                               |
    |                          Hello                                |
    |                                                               |
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;set_header('&amp;RHello');
</PRE>
</P>
<P>
<PRE>
     ---------------------------------------------------------------
    |                                                               |
    |                                                         Hello |
    |                                                               |
</PRE>
</P>
<P>
For simple text, if you do not specify any justification the text will be
centred. However, you must prefix the text with <CODE>&amp;C</CODE> if you specify a font name or any other formatting:

</P>
<P>
<PRE>
    $worksheet-&gt;set_header('Hello');
</PRE>
</P>
<P>
<PRE>
     ---------------------------------------------------------------
    |                                                               |
    |                          Hello                                |
    |                                                               |
</PRE>
</P>
<P>
You can have text in each of the justification regions:

</P>
<P>
<PRE>
    $worksheet-&gt;set_header('&amp;LCiao&amp;CBello&amp;RCielo');
</PRE>
</P>
<P>
<PRE>
     ---------------------------------------------------------------
    |                                                               |
    | Ciao                     Bello                          Cielo |
    |                                                               |
</PRE>
</P>
<P>
The information control characters act as variables that Excel will update
as the workbook or worksheet changes. Times and dates are in the users
default format:

</P>
<P>
<PRE>
    $worksheet-&gt;set_header('&amp;CPage &amp;P of &amp;N');
</PRE>
</P>
<P>
<PRE>
     ---------------------------------------------------------------
    |                                                               |
    |                        Page 1 of 6                            |
    |                                                               |
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;set_header('&amp;CUpdated at &amp;T');
</PRE>
</P>
<P>
<PRE>
     ---------------------------------------------------------------
    |                                                               |
    |                    Updated at 12:30 PM                        |
    |                                                               |
</PRE>
</P>
<P>
You can specify the font size of a section of the text by prefixing it with
the control character <CODE>&amp;n</CODE> where <CODE>n</CODE> is the font size:

</P>
<P>
<PRE>
    $worksheet1-&gt;set_header('&amp;C&amp;30Hello Big'  );
    $worksheet2-&gt;set_header('&amp;C&amp;10Hello Small');
</PRE>
</P>
<P>
You can specify the font of a section of the text by prefixing it with the
control sequence <CODE>&amp;&quot;font,style&quot;</CODE> where <CODE>fontname</CODE> is a font name such as "Courier New" or "Times New Roman" and <CODE>style</CODE> is one of the standard Windows font descriptions: "Regular", "Italic",
"Bold" or "Bold Italic":

</P>
<P>
<PRE>
    $worksheet1-&gt;set_header('&amp;C&amp;&quot;Courier New,Italic&quot;Hello');
    $worksheet2-&gt;set_header('&amp;C&amp;&quot;Courier New,Bold Italic&quot;Hello');
    $worksheet3-&gt;set_header('&amp;C&amp;&quot;Times New Roman,Regular&quot;Hello');
</PRE>
</P>
<P>
It is possible to combine all of these features together to create
sophisticated headers and footers. As an aid to setting up complicated
headers and footers you can record a page set-up as a macro in Excel and
look at the format strings that VBA produces. Remember however that VBA
uses two double quotes <CODE>&quot;&quot;</CODE> to indicate a single double quote. For the last example above the
equivalent VBA code looks like this:

</P>
<P>
<PRE>
    .LeftHeader   = &quot;&quot;
    .CenterHeader = &quot;&amp;&quot;&quot;Times New Roman,Regular&quot;&quot;Hello&quot;
    .RightHeader  = &quot;&quot;
</PRE>
</P>
<P>
To include a single literal ampersand <CODE>&amp;</CODE> in a header or footer you should use a double ampersand <CODE>&amp;&amp;</CODE>:

</P>
<P>
<PRE>
    $worksheet1-&gt;set_header('&amp;CCuriouser &amp;&amp; Curiouser - Attorneys at Law');
</PRE>
</P>
<P>
As stated above the margin parameter is optional. As with the other margins
the value should be in inches. The default header and footer margin is 0.50
inch. The header and footer margin size can be set as follows:

</P>
<P>
<PRE>
    $worksheet-&gt;set_header('&amp;CHello', 0.75);
</PRE>
</P>
<P>
The header and footer margins are independent of the top and bottom
margins.

</P>
<P>
Note, the header or footer string must be less than 255 characters. Strings
longer than this will not be written and a warning will be generated.

</P>
<P>
On systems with <CODE>perl 5.8</CODE> and later the <CODE>set_header()</CODE> method can also handle Unicode strings in <CODE>UTF-8</CODE> format.

</P>
<P>
<PRE>
    $worksheet-&gt;set_header(&quot;&amp;C\x{263a}&quot;)
</PRE>
</P>
<P>
See, also the <CODE>headers.pl</CODE> program in the <CODE>examples</CODE> directory of the distribution.

</P>
<P>
<HR>
<H2><A NAME="set_footer_">set_footer()</A></H2>
<P>
The syntax of the <CODE>set_footer()</CODE> method is the same as <CODE>set_header()</CODE>, see above.

</P>
<P>
<HR>
<H2><A NAME="repeat_rows_first_row_last_ro">repeat_rows($first_row, $last_row)</A></H2>
<P>
Set the number of rows to repeat at the top of each printed page.

</P>
<P>
For large Excel documents it is often desirable to have the first row or
rows of the worksheet print out at the top of each page. This can be
achieved by using the <CODE>repeat_rows()</CODE> method. The parameters <CODE>$first_row</CODE> and <CODE>$last_row</CODE> are zero based. The <CODE>$last_row</CODE> parameter is optional if you only wish to specify one row:

</P>
<P>
<PRE>
    $worksheet1-&gt;repeat_rows(0);    # Repeat the first row
    $worksheet2-&gt;repeat_rows(0, 1); # Repeat the first two rows
</PRE>
</P>
<P>
<HR>
<H2><A NAME="repeat_columns_first_col_last">repeat_columns($first_col, $last_col)</A></H2>
<P>
Set the columns to repeat at the left hand side of each printed page.

</P>
<P>
For large Excel documents it is often desirable to have the first column or
columns of the worksheet print out at the left hand side of each page. This
can be achieved by using the <CODE>repeat_columns()</CODE> method. The parameters <CODE>$first_column</CODE> and <CODE>$last_column</CODE> are zero based. The <CODE>$last_column</CODE> parameter is optional if you only wish to specify one column. You can also
specify the columns using A1 column notation, see the note about <A HREF="#Cell_notation">Cell notation</A>.

</P>
<P>
<PRE>
    $worksheet1-&gt;repeat_columns(0);     # Repeat the first column
    $worksheet2-&gt;repeat_columns(0, 1);  # Repeat the first two columns
    $worksheet3-&gt;repeat_columns('A:A'); # Repeat the first column
    $worksheet4-&gt;repeat_columns('A:B'); # Repeat the first two columns
</PRE>
</P>
<P>
<HR>
<H2><A NAME="hide_gridlines_option_">hide_gridlines($option)</A></H2>
<P>
This method is used to hide the gridlines on the screen and printed page.
Gridlines are the lines that divide the cells on a worksheet. Screen and
printed gridlines are turned on by default in an Excel worksheet. If you
have defined your own cell borders you may wish to hide the default
gridlines.

</P>
<P>
<PRE>
    $worksheet-&gt;hide_gridlines();
</PRE>
</P>
<P>
The following values of <CODE>$option</CODE> are valid:

</P>
<P>
<PRE>
    0 : Don't hide gridlines
    1 : Hide printed gridlines only
    2 : Hide screen and printed gridlines
</PRE>
</P>
<P>
If you don't supply an argument or use <CODE>undef</CODE> the default option is 1, i.e. only the printed gridlines are hidden.

</P>
<P>
<HR>
<H2><A NAME="print_row_col_headers_">print_row_col_headers()</A></H2>
<P>
Set the option to print the row and column headers on the printed page.

</P>
<P>
An Excel worksheet looks something like the following;

</P>
<P>
<PRE>
     ------------------------------------------
    |   |   A   |   B   |   C   |   D   |  ...
     ------------------------------------------
    | 1 |       |       |       |       |  ...
    | 2 |       |       |       |       |  ...
    | 3 |       |       |       |       |  ...
    | 4 |       |       |       |       |  ...
    |...|  ...  |  ...  |  ...  |  ...  |  ...
</PRE>
</P>
<P>
The headers are the letters and numbers at the top and the left of the
worksheet. Since these headers serve mainly as a indication of position on
the worksheet they generally do not appear on the printed page. If you wish
to have them printed you can use the <CODE>print_row_col_headers()</CODE> method :

</P>
<P>
<PRE>
    $worksheet-&gt;print_row_col_headers();
</PRE>
</P>
<P>
Do not confuse these headers with page headers as described in the <CODE>set_header()</CODE> section above.

</P>
<P>
<HR>
<H2><A NAME="print_area_first_row_first_co">print_area($first_row, $first_col, $last_row, $last_col)</A></H2>
<P>
This method is used to specify the area of the worksheet that will be
printed. All four parameters must be specified. You can also use A1
notation, see the note about <A HREF="#Cell_notation">Cell notation</A>.

</P>
<P>
<PRE>
    $worksheet1-&gt;print_area('A1:H20');    # Cells A1 to H20
    $worksheet2-&gt;print_area(0, 0, 19, 7); # The same
    $worksheet2-&gt;print_area('A:H');       # Columns A to H if rows have data
</PRE>
</P>
<P>
<HR>
<H2><A NAME="print_across_">print_across()</A></H2>
<P>
The <CODE>print_across</CODE> method is used to change the default print direction. This is referred to
by Excel as the sheet "page order".

</P>
<P>
<PRE>
    $worksheet-&gt;print_across();
</PRE>
</P>
<P>
The default page order is shown below for a worksheet that extends over 4
pages. The order is called "down then across":

</P>
<P>
<PRE>
    [1] [3]
    [2] [4]
</PRE>
</P>
<P>
However, by using the <CODE>print_across</CODE> method the print order will be changed to "across then down":

</P>
<P>
<PRE>
    [1] [2]
    [3] [4]
</PRE>
</P>
<P>
<HR>
<H2><A NAME="fit_to_pages_width_height_">fit_to_pages($width, $height)</A></H2>
<P>
The <CODE>fit_to_pages()</CODE> method is used to fit the printed area to a specific number of pages both
vertically and horizontally. If the printed area exceeds the specified
number of pages it will be scaled down to fit. This guarantees that the
printed area will always appear on the specified number of pages even if
the page size or margins change.

</P>
<P>
<PRE>
    $worksheet1-&gt;fit_to_pages(1, 1); # Fit to 1x1 pages
    $worksheet2-&gt;fit_to_pages(2, 1); # Fit to 2x1 pages
    $worksheet3-&gt;fit_to_pages(1, 2); # Fit to 1x2 pages
</PRE>
</P>
<P>
The print area can be defined using the <CODE>print_area()</CODE> method as described above.

</P>
<P>
A common requirement is to fit the printed output to <EM>n</EM> pages wide but have the height be as long as necessary. To achieve this set
the <CODE>$height</CODE> to zero or leave it blank:

</P>
<P>
<PRE>
    $worksheet1-&gt;fit_to_pages(1, 0); # 1 page wide and as long as necessary
    $worksheet2-&gt;fit_to_pages(1);    # The same
</PRE>
</P>
<P>
Note that although it is valid to use both <CODE>fit_to_pages()</CODE> and <CODE>set_print_scale()</CODE> on the same worksheet only one of these options can be active at a time.
The last method call made will set the active option.

</P>
<P>
Note that <CODE>fit_to_pages()</CODE> will override any manual page breaks that are defined in the worksheet.

</P>
<P>
<HR>
<H2><A NAME="set_start_page_start_page_">set_start_page($start_page)</A></H2>
<P>
The <CODE>set_start_page()</CODE> method is used to set the number of the starting page when the worksheet is
printed out. The default value is 1.

</P>
<P>
<PRE>
    $worksheet-&gt;set_start_page(2);
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_print_scale_scale_">set_print_scale($scale)</A></H2>
<P>
Set the scale factor of the printed page. Scale factors in the range <CODE>10 &lt;= $scale &lt;= 400</CODE> are valid:

</P>
<P>
<PRE>
    $worksheet1-&gt;set_print_scale(50);
    $worksheet2-&gt;set_print_scale(75);
    $worksheet3-&gt;set_print_scale(300);
    $worksheet4-&gt;set_print_scale(400);
</PRE>
</P>
<P>
The default scale factor is 100. Note, <CODE>set_print_scale()</CODE> does not affect the scale of the visible page in Excel. For that you should
use <CODE>set_zoom()</CODE>.

</P>
<P>
Note also that although it is valid to use both <CODE>fit_to_pages()</CODE> and <CODE>set_print_scale()</CODE> on the same worksheet only one of these options can be active at a time.
The last method call made will set the active option.

</P>
<P>
<HR>
<H2><A NAME="set_h_pagebreaks_breaks_">set_h_pagebreaks(@breaks)</A></H2>
<P>
Add horizontal page breaks to a worksheet. A page break causes all the data
that follows it to be printed on the next page. Horizontal page breaks act
between rows. To create a page break between rows 20 and 21 you must
specify the break at row 21. However in zero index notation this is
actually row 20. So you can pretend for a small while that you are using 1
index notation:

</P>
<P>
<PRE>
    $worksheet1-&gt;set_h_pagebreaks(20); # Break between row 20 and 21
</PRE>
</P>
<P>
The <CODE>set_h_pagebreaks()</CODE> method will accept a list of page breaks and you can call it more than
once:

</P>
<P>
<PRE>
    $worksheet2-&gt;set_h_pagebreaks( 20,  40,  60,  80, 100); # Add breaks
    $worksheet2-&gt;set_h_pagebreaks(120, 140, 160, 180, 200); # Add some more
</PRE>
</P>
<P>
Note: If you specify the "fit to page" option via the <CODE>fit_to_pages()</CODE> method it will override all manual page breaks.

</P>
<P>
There is a silent limitation of about 1000 horizontal page breaks per
worksheet in line with an Excel internal limitation.

</P>
<P>
<HR>
<H2><A NAME="set_v_pagebreaks_breaks_">set_v_pagebreaks(@breaks)</A></H2>
<P>
Add vertical page breaks to a worksheet. A page break causes all the data
that follows it to be printed on the next page. Vertical page breaks act
between columns. To create a page break between columns 20 and 21 you must
specify the break at column 21. However in zero index notation this is
actually column 20. So you can pretend for a small while that you are using
1 index notation:

</P>
<P>
<PRE>
    $worksheet1-&gt;set_v_pagebreaks(20); # Break between column 20 and 21
</PRE>
</P>
<P>
The <CODE>set_v_pagebreaks()</CODE> method will accept a list of page breaks and you can call it more than
once:

</P>
<P>
<PRE>
    $worksheet2-&gt;set_v_pagebreaks( 20,  40,  60,  80, 100); # Add breaks
    $worksheet2-&gt;set_v_pagebreaks(120, 140, 160, 180, 200); # Add some more
</PRE>
</P>
<P>
Note: If you specify the "fit to page" option via the <CODE>fit_to_pages()</CODE> method it will override all manual page breaks.

</P>
<P>
<HR>
<H1><A NAME="CELL_FORMATTING">CELL FORMATTING</A></H1>
<P>
This section describes the methods and properties that are available for
formatting cells in Excel. The properties of a cell that can be formatted
include: fonts, colours, patterns, borders, alignment and number
formatting.

</P>
<P>
<HR>
<H2><A NAME="Creating_and_using_a_Format_obje">Creating and using a Format object</A></H2>
<P>
Cell formatting is defined through a Format object. Format objects are
created by calling the workbook <CODE>add_format()</CODE> method as follows:

</P>
<P>
<PRE>
    my $format1 = $workbook-&gt;add_format();       # Set properties later
    my $format2 = $workbook-&gt;add_format(%props); # Set at creation
</PRE>
</P>
<P>
The format object holds all the formatting properties that can be applied
to a cell, a row or a column. The process of setting these properties is
discussed in the next section.

</P>
<P>
Once a Format object has been constructed and it properties have been set
it can be passed as an argument to the worksheet <CODE>write</CODE> methods as follows:

</P>
<P>
<PRE>
    $worksheet-&gt;write(0, 0, 'One', $format);
    $worksheet-&gt;write_string(1, 0, 'Two', $format);
    $worksheet-&gt;write_number(2, 0, 3, $format);
    $worksheet-&gt;write_blank(3, 0, $format);
</PRE>
</P>
<P>
Formats can also be passed to the worksheet <CODE>set_row()</CODE> and <CODE>set_column()</CODE> methods to define the default property for a row or column.

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(0, 15, $format);
    $worksheet-&gt;set_column(0, 0, 15, $format);
</PRE>
</P>
<P>
<HR>
<H2><A NAME="Format_methods_and_Format_proper">Format methods and Format properties</A></H2>
<P>
The following table shows the Excel format categories, the formatting
properties that can be applied and the equivalent object method:

</P>
<P>
<PRE>
    Category   Description       Property        Method Name
    --------   -----------       --------        -----------
    Font       Font type         font            set_font()
               Font size         size            set_size()
               Font color        color           set_color()
               Bold              bold            set_bold()
               Italic            italic          set_italic()
               Underline         underline       set_underline()
               Strikeout         font_strikeout  set_font_strikeout()
               Super/Subscript   font_script     set_font_script()
               Outline           font_outline    set_font_outline()
               Shadow            font_shadow     set_font_shadow()
</PRE>
</P>
<P>
<PRE>
    Number     Numeric format    num_format      set_num_format()
</PRE>
</P>
<P>
<PRE>
    Protection Lock cells        locked          set_locked()
               Hide formulas     hidden          set_hidden()
</PRE>
</P>
<P>
<PRE>
    Alignment  Horizontal align  align           set_align()
               Vertical align    valign          set_align()
               Rotation          rotation        set_rotation()
               Text wrap         text_wrap       set_text_wrap()
               Justify last      text_justlast   set_text_justlast()
               Center across     center_across   set_center_across()
               Indentation       indent          set_indent()
               Shrink to fit     shrink          set_shrink()
</PRE>
</P>
<P>
<PRE>
    Pattern    Cell pattern      pattern         set_pattern()
               Background color  bg_color        set_bg_color()
               Foreground color  fg_color        set_fg_color()
</PRE>
</P>
<P>
<PRE>
    Border     Cell border       border          set_border()
               Bottom border     bottom          set_bottom()
               Top border        top             set_top()
               Left border       left            set_left()
               Right border      right           set_right()
               Border color      border_color    set_border_color()
               Bottom color      bottom_color    set_bottom_color()
               Top color         top_color       set_top_color()
               Left color        left_color      set_left_color()
               Right color       right_color     set_right_color()
</PRE>
</P>
<P>
There are two ways of setting Format properties: by using the object method
interface or by setting the property directly. For example, a typical use
of the method interface would be as follows:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_bold();
    $format-&gt;set_color('red');
</PRE>
</P>
<P>
By comparison the properties can be set directly by passing a hash of
properties to the Format constructor:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format(bold =&gt; 1, color =&gt; 'red');
</PRE>
</P>
<P>
or after the Format has been constructed by means of the <CODE>set_properties()</CODE> method as follows:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_properties(bold =&gt; 1, color =&gt; 'red');
</PRE>
</P>
<P>
You can also store the properties in one or more named hashes and pass them
to the required method:

</P>
<P>
<PRE>
    my %font    = (
                    font  =&gt; 'Arial',
                    size  =&gt; 12,
                    color =&gt; 'blue',
                    bold  =&gt; 1,
                  );
</PRE>
</P>
<P>
<PRE>
    my %shading = (
                    bg_color =&gt; 'green',
                    pattern  =&gt; 1,
                  );
</PRE>
</P>
<P>
<PRE>
    my $format1 = $workbook-&gt;add_format(%font);           # Font only
    my $format2 = $workbook-&gt;add_format(%font, %shading); # Font and shading
</PRE>
</P>
<P>
The provision of two ways of setting properties might lead you to wonder
which is the best way. The answer depends on the amount of formatting that
will be required in your program. Initially, Spreadsheet::WriteExcel only
allowed individual Format properties to be set via the appropriate method.
While this was sufficient for most circumstances it proved very cumbersome
in programs that required a large amount of formatting. In addition the
mechanism for reusing properties between Format objects was complicated.

</P>
<P>
As a result the Perl/Tk style of adding properties was added to, hopefully,
facilitate developers who need to define a lot of formatting. In fact the
Tk style of defining properties is also supported:

</P>
<P>
<PRE>
    my %font    = (
                    -font      =&gt; 'Arial',
                    -size      =&gt; 12,
                    -color     =&gt; 'blue',
                    -bold      =&gt; 1,
                  );
</PRE>
</P>
<P>
An additional advantage of working with hashes of properties is that it
allows you to share formatting between workbook objects

</P>
<P>
You can also create a format "on the fly" and pass it directly to a write
method as follows:

</P>
<P>
<PRE>
    $worksheet-&gt;write('A1', &quot;Title&quot;, $workbook-&gt;add_format(bold =&gt; 1));
</PRE>
</P>
<P>
This corresponds to an "anonymous" format in the Perl sense of anonymous
data or subs.

</P>
<P>
<HR>
<H2><A NAME="Working_with_formats">Working with formats</A></H2>
<P>
The default format is Arial 10 with all other properties off.

</P>
<P>
Each unique format in Spreadsheet::WriteExcel must have a corresponding
Format object. It isn't possible to use a Format with a
<CODE>write()</CODE> method and then redefine the Format for use at a later
stage. This is because a Format is applied to a cell not in its current
state but in its final state. Consider the following example:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_bold();
    $format-&gt;set_color('red');
    $worksheet-&gt;write('A1', 'Cell A1', $format);
    $format-&gt;set_color('green');
    $worksheet-&gt;write('B1', 'Cell B1', $format);
</PRE>
</P>
<P>
Cell A1 is assigned the Format <CODE>$format</CODE> which is initially set to the colour red. However, the colour is
subsequently set to green. When Excel displays Cell A1 it will display the
final state of the Format which in this case will be the colour green.

</P>
<P>
In general a method call without an argument will turn a property on, for
example:

</P>
<P>
<PRE>
    my $format1 = $workbook-&gt;add_format();
    $format1-&gt;set_bold();  # Turns bold on
    $format1-&gt;set_bold(1); # Also turns bold on
    $format1-&gt;set_bold(0); # Turns bold off
</PRE>
</P>
<P>
<HR>
<H1><A NAME="FORMAT_METHODS">FORMAT METHODS</A></H1>
<P>
The Format object methods are described in more detail in the following
sections. In addition, there is a Perl program called <CODE>formats.pl</CODE> in the <CODE>examples</CODE> directory of the WriteExcel distribution. This program creates an Excel
workbook called <CODE>formats.xls</CODE> which contains examples of almost all the format types.

</P>
<P>
The following Format methods are available:

</P>
<P>
<PRE>
    set_font()
    set_size()
    set_color()
    set_bold()
    set_italic()
    set_underline()
    set_font_strikeout()
    set_font_script()
    set_font_outline()
    set_font_shadow()
    set_num_format()
    set_locked()
    set_hidden()
    set_align()
    set_align()
    set_rotation()
    set_text_wrap()
    set_text_justlast()
    set_center_across()
    set_indent()
    set_shrink()
    set_pattern()
    set_bg_color()
    set_fg_color()
    set_border()
    set_bottom()
    set_top()
    set_left()
    set_right()
    set_border_color()
    set_bottom_color()
    set_top_color()
    set_left_color()
    set_right_color()
</PRE>
</P>
<P>
The above methods can also be applied directly as properties. For example <CODE>$worksheet-&gt;set_bold()</CODE> is equivalent to <CODE>set_properties(bold =&gt; 1)</CODE>.

</P>
<P>
<HR>
<H2><A NAME="set_properties_properties_">set_properties(%properties)</A></H2>
<P>
The properties of an existing Format object can be set by means of <CODE>set_properties()</CODE>:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_properties(bold =&gt; 1, color =&gt; 'red');
</PRE>
</P>
<P>
You can also store the properties in one or more named hashes and pass them
to the <CODE>set_properties()</CODE> method:

</P>
<P>
<PRE>
    my %font    = (
                    font  =&gt; 'Arial',
                    size  =&gt; 12,
                    color =&gt; 'blue',
                    bold  =&gt; 1,
                  );
</PRE>
</P>
<P>
<PRE>
    my $format = $workbook-&gt;set_properties(%font);
</PRE>
</P>
<P>
This method can be used as an alternative to setting the properties with <CODE>add_format()</CODE> or the specific format methods that are detailed in the following sections.

</P>
<P>
<HR>
<H2><A NAME="set_font_fontname_">set_font($fontname)</A></H2>
<P>
<PRE>
    Default state:      Font is Arial
    Default action:     None
    Valid args:         Any valid font name
</PRE>
</P>
<P>
Specify the font used:

</P>
<P>
<PRE>
    $format-&gt;set_font('Times New Roman');
</PRE>
</P>
<P>
Excel can only display fonts that are installed on the system that it is
running on. Therefore it is best to use the fonts that come as standard
such as 'Arial', 'Times New Roman' and 'Courier New'. See also the Fonts
worksheet created by formats.pl

</P>
<P>
<HR>
<H2><A NAME="set_size_">set_size()</A></H2>
<P>
<PRE>
    Default state:      Font size is 10
    Default action:     Set font size to 1
    Valid args:         Integer values from 1 to as big as your screen.
</PRE>
</P>
<P>
Set the font size. Excel adjusts the height of a row to accommodate the
largest font size in the row. You can also explicitly specify the height of
a row using the <CODE>set_row()</CODE> worksheet method.

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_size(30);
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_color_">set_color()</A></H2>
<P>
<PRE>
    Default state:      Excels default color, usually black
    Default action:     Set the default color
    Valid args:         Integers from 8..63 or the following strings:
                        'black'
                        'blue'
                        'brown'
                        'cyan'
                        'gray'
                        'green'
                        'lime'
                        'magenta'
                        'navy'
                        'orange'
                        'pink'
                        'purple'
                        'red'
                        'silver'
                        'white'
                        'yellow'
</PRE>
</P>
<P>
Set the font colour. The <CODE>set_color()</CODE> method is used as follows:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_color('red');
    $worksheet-&gt;write(0, 0, 'wheelbarrow', $format);
</PRE>
</P>
<P>
Note: The <CODE>set_color()</CODE> method is used to set the colour of the font in a cell. To set the colour
of a cell use the <CODE>set_bg_color()</CODE> and <CODE>set_pattern()</CODE> methods.

</P>
<P>
For additional examples see the 'Named colors' and 'Standard colors'
worksheets created by formats.pl in the examples directory.

</P>
<P>
See also <A HREF="#COLOURS_IN_EXCEL">COLOURS IN EXCEL</A>.

</P>
<P>
<HR>
<H2><A NAME="set_bold_">set_bold()</A></H2>
<P>
<PRE>
    Default state:      bold is off
    Default action:     Turn bold on
    Valid args:         0, 1 [1]
</PRE>
</P>
<P>
Set the bold property of the font:

</P>
<P>
<PRE>
    $format-&gt;set_bold();  # Turn bold on
</PRE>
</P>
<P>
[1] Actually, values in the range 100..1000 are also valid. 400 is normal,
700 is bold and 1000 is very bold indeed. It is probably best to set the
value to 1 and use normal bold.

</P>
<P>
<HR>
<H2><A NAME="set_italic_">set_italic()</A></H2>
<P>
<PRE>
    Default state:      Italic is off
    Default action:     Turn italic on
    Valid args:         0, 1
</PRE>
</P>
<P>
Set the italic property of the font:

</P>
<P>
<PRE>
    $format-&gt;set_italic();  # Turn italic on
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_underline_">set_underline()</A></H2>
<P>
<PRE>
    Default state:      Underline is off
    Default action:     Turn on single underline
    Valid args:         0  = No underline
                        1  = Single underline
                        2  = Double underline
                        33 = Single accounting underline
                        34 = Double accounting underline
</PRE>
</P>
<P>
Set the underline property of the font.

</P>
<P>
<PRE>
    $format-&gt;set_underline();   # Single underline
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_font_strikeout_">set_font_strikeout()</A></H2>
<P>
<PRE>
    Default state:      Strikeout is off
    Default action:     Turn strikeout on
    Valid args:         0, 1
</PRE>
</P>
<P>
Set the strikeout property of the font.

</P>
<P>
<HR>
<H2><A NAME="set_font_script_">set_font_script()</A></H2>
<P>
<PRE>
    Default state:      Super/Subscript is off
    Default action:     Turn Superscript on
    Valid args:         0  = Normal
                        1  = Superscript
                        2  = Subscript
</PRE>
</P>
<P>
Set the superscript/subscript property of the font. This format is
currently not very useful.

</P>
<P>
<HR>
<H2><A NAME="set_font_outline_">set_font_outline()</A></H2>
<P>
<PRE>
    Default state:      Outline is off
    Default action:     Turn outline on
    Valid args:         0, 1
</PRE>
</P>
<P>
Macintosh only.

</P>
<P>
<HR>
<H2><A NAME="set_font_shadow_">set_font_shadow()</A></H2>
<P>
<PRE>
    Default state:      Shadow is off
    Default action:     Turn shadow on
    Valid args:         0, 1
</PRE>
</P>
<P>
Macintosh only.

</P>
<P>
<HR>
<H2><A NAME="set_num_format_">set_num_format()</A></H2>
<P>
<PRE>
    Default state:      General format
    Default action:     Format index 1
    Valid args:         See the following table
</PRE>
</P>
<P>
This method is used to define the numerical format of a number in Excel. It
controls whether a number is displayed as an integer, a floating point
number, a date, a currency value or some other user defined format.

</P>
<P>
The numerical format of a cell can be specified by using a format string or
an index to one of Excel's built-in formats:

</P>
<P>
<PRE>
    my $format1 = $workbook-&gt;add_format();
    my $format2 = $workbook-&gt;add_format();
    $format1-&gt;set_num_format('d mmm yyyy'); # Format string
    $format2-&gt;set_num_format(0x0f);         # Format index
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(0, 0, 36892.521, $format1);      # 1 Jan 2001
    $worksheet-&gt;write(0, 0, 36892.521, $format2);      # 1-Jan-01
</PRE>
</P>
<P>
Using format strings you can define very sophisticated formatting of
numbers.

</P>
<P>
<PRE>
    $format01-&gt;set_num_format('0.000');
    $worksheet-&gt;write(0,  0, 3.1415926, $format01);    # 3.142
</PRE>
</P>
<P>
<PRE>
    $format02-&gt;set_num_format('#,##0');
    $worksheet-&gt;write(1,  0, 1234.56,   $format02);    # 1,235
</PRE>
</P>
<P>
<PRE>
    $format03-&gt;set_num_format('#,##0.00');
    $worksheet-&gt;write(2,  0, 1234.56,   $format03);    # 1,234.56
</PRE>
</P>
<P>
<PRE>
    $format04-&gt;set_num_format('$0.00');
    $worksheet-&gt;write(3,  0, 49.99,     $format04);    # $49.99
</PRE>
</P>
<P>
<PRE>
    # Note you can use other currency symbols such as the pound or yen as well.
    # Other currencies may require the use of Unicode.
</PRE>
</P>
<P>
<PRE>
    $format07-&gt;set_num_format('mm/dd/yy');
    $worksheet-&gt;write(6,  0, 36892.521, $format07);    # 01/01/01
</PRE>
</P>
<P>
<PRE>
    $format08-&gt;set_num_format('mmm d yyyy');
    $worksheet-&gt;write(7,  0, 36892.521, $format08);    # Jan 1 2001
</PRE>
</P>
<P>
<PRE>
    $format09-&gt;set_num_format('d mmmm yyyy');
    $worksheet-&gt;write(8,  0, 36892.521, $format09);    # 1 January 2001
</PRE>
</P>
<P>
<PRE>
    $format10-&gt;set_num_format('dd/mm/yyyy hh:mm AM/PM');
    $worksheet-&gt;write(9,  0, 36892.521, $format10);    # 01/01/2001 12:30 AM
</PRE>
</P>
<P>
<PRE>
    $format11-&gt;set_num_format('0 &quot;dollar and&quot; .00 &quot;cents&quot;');
    $worksheet-&gt;write(10, 0, 1.87,      $format11);    # 1 dollar and .87 cents
</PRE>
</P>
<P>
<PRE>
    # Conditional formatting
    $format12-&gt;set_num_format('[Green]General;[Red]-General;General');
    $worksheet-&gt;write(11, 0, 123,       $format12);    # &gt; 0 Green
    $worksheet-&gt;write(12, 0, -45,       $format12);    # &lt; 0 Red
    $worksheet-&gt;write(13, 0, 0,         $format12);    # = 0 Default colour
</PRE>
</P>
<P>
<PRE>
    # Zip code
    $format13-&gt;set_num_format('00000');
    $worksheet-&gt;write(14, 0, '01209',   $format13);
</PRE>
</P>
<P>
The number system used for dates is described in <A HREF="#DATES_AND_TIME_IN_EXCEL">DATES AND TIME IN EXCEL</A>.

</P>
<P>
The colour format should have one of the following values:

</P>
<P>
<PRE>
    [Black] [Blue] [Cyan] [Green] [Magenta] [Red] [White] [Yellow]
</PRE>
</P>
<P>
Alternatively you can specify the colour based on a colour index as
follows: <CODE>[Color n]</CODE>, where n is a standard Excel colour index - 7. See the 'Standard colors'
worksheet created by formats.pl.

</P>
<P>
For more information refer to the documentation on formatting in the <CODE>doc</CODE> directory of the Spreadsheet::WriteExcel distro, the Excel on-line help or
<A
HREF="http://office.microsoft.com/en-gb/assistance/HP051995001033.aspx">http://office.microsoft.com/en-gb/assistance/HP051995001033.aspx</A>


</P>
<P>
You should ensure that the format string is valid in Excel prior to using
it in WriteExcel.

</P>
<P>
Excel's built-in formats are shown in the following table:

</P>
<P>
<PRE>
    Index   Index   Format String
    0       0x00    General
    1       0x01    0
    2       0x02    0.00
    3       0x03    #,##0
    4       0x04    #,##0.00
    5       0x05    ($#,##0_);($#,##0)
    6       0x06    ($#,##0_);[Red]($#,##0)
    7       0x07    ($#,##0.00_);($#,##0.00)
    8       0x08    ($#,##0.00_);[Red]($#,##0.00)
    9       0x09    0%
    10      0x0a    0.00%
    11      0x0b    0.00E+00
    12      0x0c    # ?/?
    13      0x0d    # ??/??
    14      0x0e    m/d/yy
    15      0x0f    d-mmm-yy
    16      0x10    d-mmm
    17      0x11    mmm-yy
    18      0x12    h:mm AM/PM
    19      0x13    h:mm:ss AM/PM
    20      0x14    h:mm
    21      0x15    h:mm:ss
    22      0x16    m/d/yy h:mm
    ..      ....    ...........
    37      0x25    (#,##0_);(#,##0)
    38      0x26    (#,##0_);[Red](#,##0)
    39      0x27    (#,##0.00_);(#,##0.00)
    40      0x28    (#,##0.00_);[Red](#,##0.00)
    41      0x29    _(* #,##0_);_(* (#,##0);_(* &quot;-&quot;_);_(@_)
    42      0x2a    _($* #,##0_);_($* (#,##0);_($* &quot;-&quot;_);_(@_)
    43      0x2b    _(* #,##0.00_);_(* (#,##0.00);_(* &quot;-&quot;??_);_(@_)
    44      0x2c    _($* #,##0.00_);_($* (#,##0.00);_($* &quot;-&quot;??_);_(@_)
    45      0x2d    mm:ss
    46      0x2e    [h]:mm:ss
    47      0x2f    mm:ss.0
    48      0x30    ##0.0E+0
    49      0x31    @
</PRE>
</P>
<P>
For examples of these formatting codes see the 'Numerical formats'
worksheet created by formats.pl. See also the number_formats1.html and the
number_formats2.html documents in the <CODE>doc</CODE> directory of the distro.

</P>
<P>
Note 1. Numeric formats 23 to 36 are not documented by Microsoft and may
differ in international versions.

</P>
<P>
Note 2. In Excel 5 the dollar sign appears as a dollar sign. In Excel
97-2000 it appears as the defined local currency symbol.

</P>
<P>
Note 3. The red negative numeric formats display slightly differently in
Excel 5 and Excel 97-2000.

</P>
<P>
<HR>
<H2><A NAME="set_locked_">set_locked()</A></H2>
<P>
<PRE>
    Default state:      Cell locking is on
    Default action:     Turn locking on
    Valid args:         0, 1
</PRE>
</P>
<P>
This property can be used to prevent modification of a cells contents.
Following Excel's convention, cell locking is turned on by default.
However, it only has an effect if the worksheet has been protected, see the
worksheet <CODE>protect()</CODE> method.

</P>
<P>
<PRE>
    my $locked  = $workbook-&gt;add_format();
    $locked-&gt;set_locked(1); # A non-op
</PRE>
</P>
<P>
<PRE>
    my $unlocked = $workbook-&gt;add_format();
    $locked-&gt;set_locked(0);
</PRE>
</P>
<P>
<PRE>
    # Enable worksheet protection
    $worksheet-&gt;protect();
</PRE>
</P>
<P>
<PRE>
    # This cell cannot be edited.
    $worksheet-&gt;write('A1', '=1+2', $locked);
</PRE>
</P>
<P>
<PRE>
    # This cell can be edited.
    $worksheet-&gt;write('A2', '=1+2', $unlocked);
</PRE>
</P>
<P>
Note: This offers weak protection even with a password, see the note in
relation to the <CODE>protect()</CODE> method.

</P>
<P>
<HR>
<H2><A NAME="set_hidden_">set_hidden()</A></H2>
<P>
<PRE>
    Default state:      Formula hiding is off
    Default action:     Turn hiding on
    Valid args:         0, 1
</PRE>
</P>
<P>
This property is used to hide a formula while still displaying its result.
This is generally used to hide complex calculations from end users who are
only interested in the result. It only has an effect if the worksheet has
been protected, see the worksheet <CODE>protect()</CODE> method.

</P>
<P>
<PRE>
    my $hidden = $workbook-&gt;add_format();
    $hidden-&gt;set_hidden();
</PRE>
</P>
<P>
<PRE>
    # Enable worksheet protection
    $worksheet-&gt;protect();
</PRE>
</P>
<P>
<PRE>
    # The formula in this cell isn't visible
    $worksheet-&gt;write('A1', '=1+2', $hidden);
</PRE>
</P>
<P>
Note: This offers weak protection even with a password, see the note in
relation to the <CODE>protect()</CODE> method.

</P>
<P>
<HR>
<H2><A NAME="set_align_">set_align()</A></H2>
<P>
<PRE>
    Default state:      Alignment is off
    Default action:     Left alignment
    Valid args:         'left'              Horizontal
                        'center'
                        'right'
                        'fill'
                        'justify'
                        'center_across'
</PRE>
</P>
<P>
<PRE>
                        'top'               Vertical
                        'vcenter'
                        'bottom'
                        'vjustify'
</PRE>
</P>
<P>
This method is used to set the horizontal and vertical text alignment
within a cell. Vertical and horizontal alignments can be combined. The
method is used as follows:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_align('center');
    $format-&gt;set_align('vcenter');
    $worksheet-&gt;set_row(0, 30);
    $worksheet-&gt;write(0, 0, 'X', $format);
</PRE>
</P>
<P>
Text can be aligned across two or more adjacent cells using the <CODE>center_across</CODE> property. However, for genuine merged cells it is better to use the <CODE>merge_range()</CODE> worksheet method.

</P>
<P>
The <CODE>vjustify</CODE> (vertical justify) option can be used to provide automatic text wrapping in
a cell. The height of the cell will be adjusted to accommodate the wrapped
text. To specify where the text wraps use the <CODE>set_text_wrap()</CODE> method.

</P>
<P>
For further examples see the 'Alignment' worksheet created by formats.pl.

</P>
<P>
<HR>
<H2><A NAME="set_center_across_">set_center_across()</A></H2>
<P>
<PRE>
    Default state:      Center across selection is off
    Default action:     Turn center across on
    Valid args:         1
</PRE>
</P>
<P>
Text can be aligned across two or more adjacent cells using the <CODE>set_center_across()</CODE> method. This is an alias for the <CODE>set_align('center_across')</CODE> method call.

</P>
<P>
Only one cell should contain the text, the other cells should be blank:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_center_across();
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(1, 1, 'Center across selection', $format);
    $worksheet-&gt;write_blank(1, 2, $format);
</PRE>
</P>
<P>
See also the <CODE>merge1.pl</CODE> to <CODE>merge6.pl</CODE> programs in the <CODE>examples</CODE> directory and the <CODE>merge_range()</CODE> method.

</P>
<P>
<HR>
<H2><A NAME="set_text_wrap_">set_text_wrap()</A></H2>
<P>
<PRE>
    Default state:      Text wrap is off
    Default action:     Turn text wrap on
    Valid args:         0, 1
</PRE>
</P>
<P>
Here is an example using the text wrap property, the escape character <CODE>\n</CODE> is used to indicate the end of line:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_text_wrap();
    $worksheet-&gt;write(0, 0, &quot;It's\na bum\nwrap&quot;, $format);
</PRE>
</P>
<P>
Excel will adjust the height of the row to accommodate the wrapped text. A
similar effect can be obtained without newlines using the <CODE>set_align('vjustify')</CODE> method. See the <CODE>textwrap.pl</CODE> program in the <CODE>examples</CODE> directory.

</P>
<P>
<HR>
<H2><A NAME="set_rotation_">set_rotation()</A></H2>
<P>
<PRE>
    Default state:      Text rotation is off
    Default action:     None
    Valid args:         Integers in the range -90 to 90 and 270
</PRE>
</P>
<P>
Set the rotation of the text in a cell. The rotation can be any angle in
the range -90 to 90 degrees.

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_rotation(30);
    $worksheet-&gt;write(0, 0, 'This text is rotated', $format);
</PRE>
</P>
<P>
The angle 270 is also supported. This indicates text where the letters run
from top to bottom.

</P>
<P>
<HR>
<H2><A NAME="set_indent_">set_indent()</A></H2>
<P>
<PRE>
    Default state:      Text indentation is off
    Default action:     Indent text 1 level
    Valid args:         Positive integers
</PRE>
</P>
<P>
This method can be used to indent text. The argument, which should be an
integer, is taken as the level of indentation:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_indent(2);
    $worksheet-&gt;write(0, 0, 'This text is indented', $format);
</PRE>
</P>
<P>
Indentation is a horizontal alignment property. It will override any other
horizontal properties but it can be used in conjunction with vertical
properties.

</P>
<P>
<HR>
<H2><A NAME="set_shrink_">set_shrink()</A></H2>
<P>
<PRE>
    Default state:      Text shrinking is off
    Default action:     Turn &quot;shrink to fit&quot; on
    Valid args:         1
</PRE>
</P>
<P>
This method can be used to shrink text so that it fits in a cell.

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_shrink();
    $worksheet-&gt;write(0, 0, 'Honey, I shrunk the text!', $format);
</PRE>
</P>
<P>
<HR>
<H2><A NAME="set_text_justlast_">set_text_justlast()</A></H2>
<P>
<PRE>
    Default state:      Justify last is off
    Default action:     Turn justify last on
    Valid args:         0, 1
</PRE>
</P>
<P>
Only applies to Far Eastern versions of Excel.

</P>
<P>
<HR>
<H2><A NAME="set_pattern_">set_pattern()</A></H2>
<P>
<PRE>
    Default state:      Pattern is off
    Default action:     Solid fill is on
    Valid args:         0 .. 18
</PRE>
</P>
<P>
Set the background pattern of a cell.

</P>
<P>
Examples of the available patterns are shown in the 'Patterns' worksheet
created by formats.pl. However, it is unlikely that you will ever need
anything other than Pattern 1 which is a solid fill of the background
color.

</P>
<P>
<HR>
<H2><A NAME="set_bg_color_">set_bg_color()</A></H2>
<P>
<PRE>
    Default state:      Color is off
    Default action:     Solid fill.
    Valid args:         See set_color()
</PRE>
</P>
<P>
The <CODE>set_bg_color()</CODE> method can be used to set the background colour of a pattern. Patterns are
defined via the <CODE>set_pattern()</CODE> method. If a pattern hasn't been defined then a solid fill pattern is used
as the default.

</P>
<P>
Here is an example of how to set up a solid fill in a cell:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format();
</PRE>
</P>
<P>
<PRE>
    $format-&gt;set_pattern(); # This is optional when using a solid fill
</PRE>
</P>
<P>
<PRE>
    $format-&gt;set_bg_color('green');
    $worksheet-&gt;write('A1', 'Ray', $format);
</PRE>
</P>
<P>
For further examples see the 'Patterns' worksheet created by formats.pl.

</P>
<P>
<HR>
<H2><A NAME="set_fg_color_">set_fg_color()</A></H2>
<P>
<PRE>
    Default state:      Color is off
    Default action:     Solid fill.
    Valid args:         See set_color()
</PRE>
</P>
<P>
The <CODE>set_fg_color()</CODE> method can be used to set the foreground colour of a pattern.

</P>
<P>
For further examples see the 'Patterns' worksheet created by formats.pl.

</P>
<P>
<HR>
<H2><A NAME="set_border_">set_border()</A></H2>
<P>
<PRE>
    Also applies to:    set_bottom()
                        set_top()
                        set_left()
                        set_right()
</PRE>
</P>
<P>
<PRE>
    Default state:      Border is off
    Default action:     Set border type 1
    Valid args:         0-13, See below.
</PRE>
</P>
<P>
A cell border is comprised of a border on the bottom, top, left and right.
These can be set to the same value using <CODE>set_border()</CODE> or individually using the relevant method calls shown above.

</P>
<P>
The following shows the border styles sorted by Spreadsheet::WriteExcel
index number:

</P>
<P>
<PRE>
    Index   Name            Weight   Style
    =====   =============   ======   ===========
    0       None            0
    1       Continuous      1        -----------
    2       Continuous      2        -----------
    3       Dash            1        - - - - - -
    4       Dot             1        . . . . . .
    5       Continuous      3        -----------
    6       Double          3        ===========
    7       Continuous      0        -----------
    8       Dash            2        - - - - - -
    9       Dash Dot        1        - . - . - .
    10      Dash Dot        2        - . - . - .
    11      Dash Dot Dot    1        - . . - . .
    12      Dash Dot Dot    2        - . . - . .
    13      SlantDash Dot   2        / - . / - .
</PRE>
</P>
<P>
The following shows the borders sorted by style:

</P>
<P>
<PRE>
    Name            Weight   Style         Index
    =============   ======   ===========   =====
    Continuous      0        -----------   7
    Continuous      1        -----------   1
    Continuous      2        -----------   2
    Continuous      3        -----------   5
    Dash            1        - - - - - -   3
    Dash            2        - - - - - -   8
    Dash Dot        1        - . - . - .   9
    Dash Dot        2        - . - . - .   10
    Dash Dot Dot    1        - . . - . .   11
    Dash Dot Dot    2        - . . - . .   12
    Dot             1        . . . . . .   4
    Double          3        ===========   6
    None            0                      0
    SlantDash Dot   2        / - . / - .   13
</PRE>
</P>
<P>
The following shows the borders in the order shown in the Excel Dialog.

</P>
<P>
<PRE>
    Index   Style             Index   Style
    =====   =====             =====   =====
    0       None              12      - . . - . .
    7       -----------       13      / - . / - .
    4       . . . . . .       10      - . - . - .
    11      - . . - . .       8       - - - - - -
    9       - . - . - .       2       -----------
    3       - - - - - -       5       -----------
    1       -----------       6       ===========
</PRE>
</P>
<P>
Examples of the available border styles are shown in the 'Borders'
worksheet created by formats.pl.

</P>
<P>
<HR>
<H2><A NAME="set_border_color_">set_border_color()</A></H2>
<P>
<PRE>
    Also applies to:    set_bottom_color()
                        set_top_color()
                        set_left_color()
                        set_right_color()
</PRE>
</P>
<P>
<PRE>
    Default state:      Color is off
    Default action:     Undefined
    Valid args:         See set_color()
</PRE>
</P>
<P>
Set the colour of the cell borders. A cell border is comprised of a border
on the bottom, top, left and right. These can be set to the same colour
using <CODE>set_border_color()</CODE> or individually using the relevant method calls shown above. Examples of
the border styles and colours are shown in the 'Borders' worksheet created
by formats.pl.

</P>
<P>
<HR>
<H2><A NAME="copy_format_">copy($format)</A></H2>
<P>
This method is used to copy all of the properties from one Format object to
another:

</P>
<P>
<PRE>
    my $lorry1 = $workbook-&gt;add_format();
    $lorry1-&gt;set_bold();
    $lorry1-&gt;set_italic();
    $lorry1-&gt;set_color('red');    # lorry1 is bold, italic and red
</PRE>
</P>
<P>
<PRE>
    my $lorry2 = $workbook-&gt;add_format();
    $lorry2-&gt;copy($lorry1);
    $lorry2-&gt;set_color('yellow'); # lorry2 is bold, italic and yellow
</PRE>
</P>
<P>
The <CODE>copy()</CODE> method is only useful if you are using the method interface to Format
properties. It generally isn't required if you are setting Format
properties directly using hashes.

</P>
<P>
Note: this is not a copy constructor, both objects must exist prior to
copying.

</P>
<P>
<HR>
<H1><A NAME="UNICODE_IN_EXCEL">UNICODE IN EXCEL</A></H1>
<P>
The following is a brief introduction to handling Unicode in <CODE>Spreadsheet::WriteExcel</CODE>.

</P>
<P>
<EM>For a more general introduction to Unicode handling in Perl see</EM>  <EM>perlunitut</EM> and <EM>perluniintro</EM>.

</P>
<P>
When using Spreadsheet::WriteExcel the best and easiest way to write
unicode strings to an Excel file is to use <CODE>UTF-8</CODE> encoded strings and perl 5.8 (or later). Spreadsheet::WriteExcel also
allows you to write unicode strings using older perls but it generally
requires more work, as explained below.

</P>
<P>
Internally, Excel encodes unicode data as <CODE>UTF-16LE</CODE> (where LE means little-endian). If you are using perl 5.8+ then
Spreadsheet::WriteExcel will convert <CODE>UTF-8</CODE> strings to <CODE>UTF-16LE</CODE> when required. No further intervention is required from the programmer, for
example:

</P>
<P>
<PRE>
    # perl 5.8+ example:
    my $smiley = &quot;\x{263A}&quot;;
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write('A1', 'Hello world'); # ASCII
    $worksheet-&gt;write('A2', $smiley);       # UTF-8
</PRE>
</P>
<P>
Spreadsheet::WriteExcel also lets you write unicode data as <CODE>UTF-16</CODE>. Since the majority of CPAN modules default to <CODE>UTF-16BE</CODE> (big-endian) Spreadsheet::WriteExcel also uses <CODE>UTF-16BE</CODE> and converts it internally to <CODE>UTF-16LE</CODE>:

</P>
<P>
<PRE>
    # perl 5.005 example:
    my $smiley = pack 'n', 0x263A;
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write               ('A3', 'Hello world'); # ASCII
    $worksheet-&gt;write_utf16be_string('A4', $smiley);       # UTF-16
</PRE>
</P>
<P>
Although the above examples look similar there is an important difference.
With <CODE>uft8</CODE> and perl 5.8+ Spreadsheet::WriteExcel treats <CODE>UTF-8</CODE> strings in exactly the same way as any other string. However, with <CODE>UTF16</CODE> data we need to distinguish it from other strings either by calling a
separate function or by passing an additional flag to indicate the data
type.

</P>
<P>
If you are dealing with non-ASCII characters that aren't in <CODE>UTF-8</CODE> then perl 5.8+ provides useful tools in the guise of the <CODE>Encode</CODE> module to help you to convert to the required format. For example:

</P>
<P>
<PRE>
    use Encode 'decode';
</PRE>
</P>
<P>
<PRE>
    my $string = 'some string with koi8-r characters';
       $string = decode('koi8-r', $string); # koi8-r to utf8
</PRE>
</P>
<P>
Alternatively you can read data from an encoded file and convert it to <CODE>UTF-8</CODE> as you read it in:

</P>
<P>
<PRE>
    my $file = 'unicode_koi8r.txt';
    open FH, '&lt;:encoding(koi8-r)', $file  or die &quot;Couldn't open $file: $!\n&quot;;
</PRE>
</P>
<P>
<PRE>
    my $row = 0;
    while (&lt;FH&gt;) {
        # Data read in is now in utf8 format.
        chomp;
        $worksheet-&gt;write($row++, 0,  $_);
    }
</PRE>
</P>
<P>
These methodologies are explained in more detail in <EM>perlunitut</EM>, <EM>perluniintro</EM> and <EM>perlunicode</EM>.

</P>
<P>
See also the <CODE>unicode_*.pl</CODE> programs in the examples directory of the distro.

</P>
<P>
<HR>
<H1><A NAME="COLOURS_IN_EXCEL">COLOURS IN EXCEL</A></H1>
<P>
Excel provides a colour palette of 56 colours. In Spreadsheet::WriteExcel
these colours are accessed via their palette index in the range 8..63. This
index is used to set the colour of fonts, cell patterns and cell borders.
For example:

</P>
<P>
<PRE>
    my $format = $workbook-&gt;add_format(
                                        color =&gt; 12, # index for blue
                                        font  =&gt; 'Arial',
                                        size  =&gt; 12,
                                        bold  =&gt; 1,
                                     );
</PRE>
</P>
<P>
The most commonly used colours can also be accessed by name. The name acts
as a simple alias for the colour index:

</P>
<P>
<PRE>
    black     =&gt;    8
    blue      =&gt;   12
    brown     =&gt;   16
    cyan      =&gt;   15
    gray      =&gt;   23
    green     =&gt;   17
    lime      =&gt;   11
    magenta   =&gt;   14
    navy      =&gt;   18
    orange    =&gt;   53
    pink      =&gt;   33
    purple    =&gt;   20
    red       =&gt;   10
    silver    =&gt;   22
    white     =&gt;    9
    yellow    =&gt;   13
</PRE>
</P>
<P>
For example:

</P>
<P>
<PRE>
    my $font = $workbook-&gt;add_format(color =&gt; 'red');
</PRE>
</P>
<P>
Users of VBA in Excel should note that the equivalent colour indices are in
the range 1..56 instead of 8..63.

</P>
<P>
If the default palette does not provide a required colour you can override
one of the built-in values. This is achieved by using the <CODE>set_custom_color()</CODE> workbook method to adjust the RGB (red green blue) components of the
colour:

</P>
<P>
<PRE>
    my $ferrari = $workbook-&gt;set_custom_color(40, 216, 12, 12);
</PRE>
</P>
<P>
<PRE>
    my $format  = $workbook-&gt;add_format(
                                        bg_color =&gt; $ferrari,
                                        pattern  =&gt; 1,
                                        border   =&gt; 1
                                      );
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write_blank('A1', $format);
</PRE>
</P>
<P>
The default Excel 97 colour palette is shown in <CODE>palette.html</CODE> in the <CODE>doc</CODE> directory of the distro. You can generate an Excel version of the palette
using <CODE>colors.pl</CODE> in the <CODE>examples</CODE> directory.

</P>
<P>
A comparison of the colour components in the Excel 5 and Excel 97+ colour
palettes is shown in <CODE>rgb5-97.txt</CODE> in the <CODE>doc</CODE> directory.

</P>
<P>
You may also find the following links helpful:

</P>
<P>
A detailed look at Excel's colour palette: <A
HREF="http://www.mvps.org/dmcritchie/excel/colors.htm">http://www.mvps.org/dmcritchie/excel/colors.htm</A>


</P>
<P>
A decimal RGB chart: <A
HREF="http://www.hypersolutions.org/pages/rgbdec.html">http://www.hypersolutions.org/pages/rgbdec.html</A>


</P>
<P>
A hex RGB chart: : <A
HREF="http://www.hypersolutions.org/pages/rgbhex.html">http://www.hypersolutions.org/pages/rgbhex.html</A>


</P>
<P>
<HR>
<H1><A NAME="DATES_AND_TIME_IN_EXCEL">DATES AND TIME IN EXCEL</A></H1>
<P>
There are two important things to understand about dates and times in
Excel:

</P>
<OL>
<LI><A NAME="item_A_date_time_in_Excel_is_a_real_n">A date/time in Excel is a real number plus an Excel number format.</A>
<LI><A NAME="item_Spreadsheet_WriteExcel_doesn_t_">Spreadsheet::WriteExcel doesn't automatically convert date/time strings in write() to an Excel date/time.</A>
</OL>
<P>
These two points are explained in more detail below along with some
suggestions on how to convert times and dates to the required format.

</P>
<P>
<HR>
<H2><A NAME="An_Excel_date_time_is_a_number_p">An Excel date/time is a number plus a format</A></H2>
<P>
If you write a date string with <CODE>write()</CODE> then all you will get is a string:

</P>
<P>
<PRE>
    $worksheet-&gt;write('A1', '02/03/04'); # !! Writes a string not a date. !!
</PRE>
</P>
<P>
Dates and times in Excel are represented by real numbers, for example "Jan
1 2001 12:30 AM&quot; is represented by the number 36892.521.

</P>
<P>
The integer part of the number stores the number of days since the epoch
and the fractional part stores the percentage of the day.

</P>
<P>
A date or time in Excel is just like any other number. To have the number
display as a date you must apply an Excel number format to it. Here are
some examples.

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('date_examples.xls');
    my $worksheet = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;set_column('A:A', 30); # For extra visibility.
</PRE>
</P>
<P>
<PRE>
    my $number    = 39506.5;
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write('A1', $number);            #     39506.5
</PRE>
</P>
<P>
<PRE>
    my $format2 = $workbook-&gt;add_format(num_format =&gt; 'dd/mm/yy');
    $worksheet-&gt;write('A2', $number , $format2); #     28/02/08
</PRE>
</P>
<P>
<PRE>
    my $format3 = $workbook-&gt;add_format(num_format =&gt; 'mm/dd/yy');
    $worksheet-&gt;write('A3', $number , $format3); #     02/28/08
</PRE>
</P>
<P>
<PRE>
    my $format4 = $workbook-&gt;add_format(num_format =&gt; 'd-m-yyyy');
    $worksheet-&gt;write('A4', $number , $format4); #     28-2-2008
</PRE>
</P>
<P>
<PRE>
    my $format5 = $workbook-&gt;add_format(num_format =&gt; 'dd/mm/yy hh:mm');
    $worksheet-&gt;write('A5', $number , $format5); #     28/02/08 12:00
</PRE>
</P>
<P>
<PRE>
    my $format6 = $workbook-&gt;add_format(num_format =&gt; 'd mmm yyyy');
    $worksheet-&gt;write('A6', $number , $format6); #     28 Feb 2008
</PRE>
</P>
<P>
<PRE>
    my $format7 = $workbook-&gt;add_format(num_format =&gt; 'mmm d yyyy hh:mm AM/PM');
    $worksheet-&gt;write('A7', $number , $format7); #     Feb 28 2008 12:00 PM
</PRE>
</P>
<P>
<HR>
<H2><A NAME="Spreadsheet_WriteExcel_doesn_t_">Spreadsheet::WriteExcel doesn't automatically convert date/time strings</A></H2>
<P>
Spreadsheet::WriteExcel doesn't automatically convert input date strings
into Excel's formatted date numbers due to the large number of possible
date formats and also due to the possibility of misintepretation.

</P>
<P>
For example, does <CODE>02/03/04</CODE> mean March 2 2004, February 3 2004 or even March 4 2002.

</P>
<P>
Therefore, in order to handle dates you will have to convert them to
numbers and apply an Excel format. Some methods for converting dates are
listed in the next section.

</P>
<P>
The most direct way is to convert your dates to the ISO8601 <CODE>yyyy-mm-ddThh:mm:ss.sss</CODE> date format and use the <CODE>write_date_time()</CODE> worksheet method:

</P>
<P>
<PRE>
    $worksheet-&gt;write_date_time('A2', '2001-01-01T12:20', $format);
</PRE>
</P>
<P>
See the <CODE>write_date_time()</CODE> section of the documentation for more details.

</P>
<P>
A general methodology for handling date strings with <CODE>write_date_time()</CODE> is:

</P>
<P>
<PRE>
    1. Identify incoming date/time strings with a regex.
    2. Extract the component parts of the date/time using the same regex.
    3. Convert the date/time to the ISO8601 format.
    4. Write the date/time using write_date_time() and a number format.
</PRE>
</P>
<P>
Here is an example:

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    my $workbook    = Spreadsheet::WriteExcel-&gt;new('example.xls');
    my $worksheet   = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    # Set the default format for dates.
    my $date_format = $workbook-&gt;add_format(num_format =&gt; 'mmm d yyyy');
</PRE>
</P>
<P>
<PRE>
    # Increase column width to improve visibility of data.
    $worksheet-&gt;set_column('A:C', 20);
</PRE>
</P>
<P>
<PRE>
    # Simulate reading from a data source.
    my $row = 0;
</PRE>
</P>
<P>
<PRE>
    while (&lt;DATA&gt;) {
        chomp;
</PRE>
</P>
<P>
<PRE>
        my $col  = 0;
        my @data = split ' ';
</PRE>
</P>
<P>
<PRE>
        for my $item (@data) {
</PRE>
</P>
<P>
<PRE>
            # Match dates in the following formats: d/m/yy, d/m/yyyy
            if ($item =~ qr[^(\d{1,2})/(\d{1,2})/(\d{4})$]) {
</PRE>
</P>
<P>
<PRE>
                # Change to the date format required by write_date_time().
                my $date = sprintf &quot;%4d-%02d-%02dT&quot;, $3, $2, $1;
</PRE>
</P>
<P>
<PRE>
                $worksheet-&gt;write_date_time($row, $col++, $date, $date_format);
            }
            else {
                # Just plain data
                $worksheet-&gt;write($row, $col++, $item);
            }
        }
        $row++;
    }
</PRE>
</P>
<P>
<PRE>
    __DATA__
    Item    Cost    Date
    Book    10      1/9/2007
    Beer    4       12/9/2007
    Bed     500     5/10/2007
</PRE>
</P>
<P>
For a slightly more advanced solution you can modify the <CODE>write()</CODE> method to handle date formats of your choice via the <CODE>add_write_handler()</CODE> method. See the <CODE>add_write_handler()</CODE> section of the docs and the write_handler3.pl and write_handler4.pl
programs in the examples directory of the distro.

</P>
<P>
<HR>
<H2><A NAME="Converting_dates_and_times_to_an">Converting dates and times to an Excel date or time</A></H2>
<P>
The <CODE>write_date_time()</CODE> method above is just one way of handling dates and times.

</P>
<P>
The <A HREF="/Spreadsheet/WriteExcel/Utility.html">Spreadsheet::WriteExcel::Utility</A> module which is included in the distro has date/time handling functions:

</P>
<P>
<PRE>
    use Spreadsheet::WriteExcel::Utility;
</PRE>
</P>
<P>
<PRE>
    $date           = xl_date_list(2002, 1, 1);         # 37257
    $date           = xl_parse_date(&quot;11 July 1997&quot;);    # 35622
    $time           = xl_parse_time('3:21:36 PM');      # 0.64
    $date           = xl_decode_date_EU(&quot;13 May 2002&quot;); # 37389
</PRE>
</P>
<P>
Note: some of these functions require additional CPAN modules.

</P>
<P>
For date conversions using the CPAN <CODE>DateTime</CODE> framework see <A HREF="/DateTime/Format/Excel.html">DateTime::Format::Excel</A> <A
HREF="http://search.cpan.org/search?dist=DateTime-Format-Excel">http://search.cpan.org/search?dist=DateTime-Format-Excel</A>


</P>
<P>
<HR>
<H1><A NAME="OUTLINES_AND_GROUPING_IN_EXCEL">OUTLINES AND GROUPING IN EXCEL</A></H1>
<P>
Excel allows you to group rows or columns so that they can be hidden or
displayed with a single mouse click. This feature is referred to as
outlines.

</P>
<P>
Outlines can reduce complex data down to a few salient sub-totals or
summaries.

</P>
<P>
This feature is best viewed in Excel but the following is an ASCII
representation of what a worksheet with three outlines might look like.
Rows 3-4 and rows 7-8 are grouped at level 2. Rows 2-9 are grouped at level
1. The lines at the left hand side are called outline level bars.

</P>
<P>
<PRE>
            ------------------------------------------
     1 2 3 |   |   A   |   B   |   C   |   D   |  ...
            ------------------------------------------
      _    | 1 |   A   |       |       |       |  ...
     |  _  | 2 |   B   |       |       |       |  ...
     | |   | 3 |  (C)  |       |       |       |  ...
     | |   | 4 |  (D)  |       |       |       |  ...
     | -   | 5 |   E   |       |       |       |  ...
     |  _  | 6 |   F   |       |       |       |  ...
     | |   | 7 |  (G)  |       |       |       |  ...
     | |   | 8 |  (H)  |       |       |       |  ...
     | -   | 9 |   I   |       |       |       |  ...
     -     | . |  ...  |  ...  |  ...  |  ...  |  ...
</PRE>
</P>
<P>
Clicking the minus sign on each of the level 2 outlines will collapse and
hide the data as shown in the next figure. The minus sign changes to a plus
sign to indicate that the data in the outline is hidden.

</P>
<P>
<PRE>
            ------------------------------------------
     1 2 3 |   |   A   |   B   |   C   |   D   |  ...
            ------------------------------------------
      _    | 1 |   A   |       |       |       |  ...
     |     | 2 |   B   |       |       |       |  ...
     | +   | 5 |   E   |       |       |       |  ...
     |     | 6 |   F   |       |       |       |  ...
     | +   | 9 |   I   |       |       |       |  ...
     -     | . |  ...  |  ...  |  ...  |  ...  |  ...
</PRE>
</P>
<P>
Clicking on the minus sign on the level 1 outline will collapse the
remaining rows as follows:

</P>
<P>
<PRE>
            ------------------------------------------
     1 2 3 |   |   A   |   B   |   C   |   D   |  ...
            ------------------------------------------
           | 1 |   A   |       |       |       |  ...
     +     | . |  ...  |  ...  |  ...  |  ...  |  ...
</PRE>
</P>
<P>
Grouping in <CODE>Spreadsheet::WriteExcel</CODE> is achieved by setting the outline level via the <CODE>set_row()</CODE> and <CODE>set_column()</CODE> worksheet methods:

</P>
<P>
<PRE>
    set_row($row, $height, $format, $hidden, $level, $collapsed)
    set_column($first_col, $last_col, $width, $format, $hidden, $level, $collapsed)
</PRE>
</P>
<P>
The following example sets an outline level of 1 for rows 1 and 2
(zero-indexed) and columns B to G. The parameters <CODE>$height</CODE> and <CODE>$XF</CODE> are assigned default values since they are undefined:

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(1, undef, undef, 0, 1);
    $worksheet-&gt;set_row(2, undef, undef, 0, 1);
    $worksheet-&gt;set_column('B:G', undef, undef, 0, 1);
</PRE>
</P>
<P>
Excel allows up to 7 outline levels. Therefore the <CODE>$level</CODE> parameter should be in the range <CODE>0 &lt;= $level &lt;= 7</CODE>.

</P>
<P>
Rows and columns can be collapsed by setting the <CODE>$hidden</CODE> flag for the hidden rows/columns and setting the <CODE>$collapsed</CODE> flag for the row/column that has the collapsed <CODE>+</CODE> symbol:

</P>
<P>
<PRE>
    $worksheet-&gt;set_row(1, undef, undef, 1, 1);
    $worksheet-&gt;set_row(2, undef, undef, 1, 1);
    $worksheet-&gt;set_row(3, undef, undef, 0, 0, 1);        # Collapsed flag.
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;set_column('B:G', undef, undef, 1, 1);
    $worksheet-&gt;set_column('H:H', undef, undef, 0, 0, 1); # Collapsed flag.
</PRE>
</P>
<P>
Note: Setting the <CODE>$collapsed</CODE> flag is particularly important for compatibility with OpenOffice.org and
Gnumeric.

</P>
<P>
For a more complete example see the <CODE>outline.pl</CODE> and <CODE>outline_collapsed.pl</CODE> programs in the examples directory of the distro.

</P>
<P>
Some additional outline properties can be set via the <CODE>outline_settings()</CODE> worksheet method, see above.

</P>
<P>
<HR>
<H1><A NAME="FORMULAS_AND_FUNCTIONS_IN_EXCEL">FORMULAS AND FUNCTIONS IN EXCEL</A></H1>
<P>
<HR>
<H2><A NAME="Caveats">Caveats</A></H2>
<P>
The first thing to note is that there are still some outstanding issues
with the implementation of formulas and functions:

</P>
<P>
<PRE>
    1. Writing a formula is much slower than writing the equivalent string.
    2. You cannot use array constants, i.e. {1;2;3}, in functions.
    3. Unary minus isn't supported.
    4. Whitespace is not preserved around operators.
    5. Named ranges are not supported.
    6. Array formulas are not supported.
</PRE>
</P>
<P>
However, these constraints will be removed in future versions. They are
here because of a trade-off between features and time. Also, it is possible
to work around issue 1 using the <CODE>store_formula()</CODE> and <CODE>repeat_formula()</CODE> methods as described later in this section.

</P>
<P>
<HR>
<H2><A NAME="Introduction">Introduction</A></H2>
<P>
The following is a brief introduction to formulas and functions in Excel
and Spreadsheet::WriteExcel.

</P>
<P>
A formula is a string that begins with an equals sign:

</P>
<P>
<PRE>
    '=A1+B1'
    '=AVERAGE(1, 2, 3)'
</PRE>
</P>
<P>
The formula can contain numbers, strings, boolean values, cell references,
cell ranges and functions. Named ranges are not supported. Formulas should
be written as they appear in Excel, that is cells and functions must be in
uppercase.

</P>
<P>
Cells in Excel are referenced using the A1 notation system where the column
is designated by a letter and the row by a number. Columns range from A to
IV i.e. 0 to 255, rows range from 1 to 65536. The <CODE>Spreadsheet::WriteExcel::Utility</CODE> module that is included in the distro contains helper functions for dealing
with A1 notation, for example:

</P>
<P>
<PRE>
    use Spreadsheet::WriteExcel::Utility;
</PRE>
</P>
<P>
<PRE>
    ($row, $col) = xl_cell_to_rowcol('C2');  # (1, 2)
    $str         = xl_rowcol_to_cell(1, 2);  # C2
</PRE>
</P>
<P>
The Excel <CODE>$</CODE> notation in cell references is also supported. This allows you to specify
whether a row or column is relative or absolute. This only has an effect if
the cell is copied. The following examples show relative and absolute
values.

</P>
<P>
<PRE>
    '=A1'   # Column and row are relative
    '=$A1'  # Column is absolute and row is relative
    '=A$1'  # Column is relative and row is absolute
    '=$A$1' # Column and row are absolute
</PRE>
</P>
<P>
Formulas can also refer to cells in other worksheets of the current
workbook. For example:

</P>
<P>
<PRE>
    '=Sheet2!A1'
    '=Sheet2!A1:A5'
    '=Sheet2:Sheet3!A1'
    '=Sheet2:Sheet3!A1:A5'
    q{='Test Data'!A1}
    q{='Test Data1:Test Data2'!A1}
</PRE>
</P>
<P>
The sheet reference and the cell reference are separated by  <CODE>!</CODE> the exclamation mark symbol. If worksheet names contain spaces, commas o
parentheses then Excel requires that the name is enclosed in single quotes
as shown in the last two examples above. In order to avoid using a lot of
escape characters you can use the quote operator <CODE>q{}</CODE> to protect the quotes. See <CODE>perlop</CODE> in the main Perl documentation. Only valid sheet names that have been added
using the <CODE>add_worksheet()</CODE> method can be used in formulas. You cannot reference external workbooks.

</P>
<P>
The following table lists the operators that are available in Excel's
formulas. The majority of the operators are the same as Perl's, differences
are indicated:

</P>
<P>
<PRE>
    Arithmetic operators:
    =====================
    Operator  Meaning                   Example
       +      Addition                  1+2
       -      Subtraction               2-1
       *      Multiplication            2*3
       /      Division                  1/4
       ^      Exponentiation            2^3      # Equivalent to **
       -      Unary minus               -(1+2)   # Not yet supported
       %      Percent (Not modulus)     13%      # Not supported, [1]
</PRE>
</P>
<P>
<PRE>
    Comparison operators:
    =====================
    Operator  Meaning                   Example
        =     Equal to                  A1 =  B1 # Equivalent to ==
        &lt;&gt;    Not equal to              A1 &lt;&gt; B1 # Equivalent to !=
        &gt;     Greater than              A1 &gt;  B1
        &lt;     Less than                 A1 &lt;  B1
        &gt;=    Greater than or equal to  A1 &gt;= B1
        &lt;=    Less than or equal to     A1 &lt;= B1
</PRE>
</P>
<P>
<PRE>
    String operator:
    ================
    Operator  Meaning                   Example
        &amp;     Concatenation             &quot;Hello &quot; &amp; &quot;World!&quot; # [2]
</PRE>
</P>
<P>
<PRE>
    Reference operators:
    ====================
    Operator  Meaning                   Example
        :     Range operator            A1:A4               # [3]
        ,     Union operator            SUM(1, 2+2, B3)     # [4]
</PRE>
</P>
<P>
<PRE>
    Notes:
    [1]: You can get a percentage with formatting and modulus with MOD().
    [2]: Equivalent to (&quot;Hello &quot; . &quot;World!&quot;) in Perl.
    [3]: This range is equivalent to cells A1, A2, A3 and A4.
    [4]: The comma behaves like the list separator in Perl.
</PRE>
</P>
<P>
The range and comma operators can have different symbols in non-English
versions of Excel. These will be supported in a later version of
Spreadsheet::WriteExcel. European users of Excel take note:

</P>
<P>
<PRE>
    $worksheet-&gt;write('A1', '=SUM(1; 2; 3)'); # Wrong!!
    $worksheet-&gt;write('A1', '=SUM(1, 2, 3)'); # Okay
</PRE>
</P>
<P>
The following table lists all of the core functions supported by Excel 5
and Spreadsheet::WriteExcel. Any additional functions that are available
through the "Analysis ToolPak" or other add-ins are not supported. These
functions have all been tested to verify that they work.

</P>
<P>
<PRE>
    ABS           DB            INDIRECT      NORMINV       SLN
    ACOS          DCOUNT        INFO          NORMSDIST     SLOPE
    ACOSH         DCOUNTA       INT           NORMSINV      SMALL
    ADDRESS       DDB           INTERCEPT     NOT           SQRT
    AND           DEGREES       IPMT          NOW           STANDARDIZE
    AREAS         DEVSQ         IRR           NPER          STDEV
    ASIN          DGET          ISBLANK       NPV           STDEVP
    ASINH         DMAX          ISERR         ODD           STEYX
    ATAN          DMIN          ISERROR       OFFSET        SUBSTITUTE
    ATAN2         DOLLAR        ISLOGICAL     OR            SUBTOTAL
    ATANH         DPRODUCT      ISNA          PEARSON       SUM
    AVEDEV        DSTDEV        ISNONTEXT     PERCENTILE    SUMIF
    AVERAGE       DSTDEVP       ISNUMBER      PERCENTRANK   SUMPRODUCT
    BETADIST      DSUM          ISREF         PERMUT        SUMSQ
    BETAINV       DVAR          ISTEXT        PI            SUMX2MY2
    BINOMDIST     DVARP         KURT          PMT           SUMX2PY2
    CALL          ERROR.TYPE    LARGE         POISSON       SUMXMY2
    CEILING       EVEN          LEFT          POWER         SYD
    CELL          EXACT         LEN           PPMT          T
    CHAR          EXP           LINEST        PROB          TAN
    CHIDIST       EXPONDIST     LN            PRODUCT       TANH
    CHIINV        FACT          LOG           PROPER        TDIST
    CHITEST       FALSE         LOG10         PV            TEXT
    CHOOSE        FDIST         LOGEST        QUARTILE      TIME
    CLEAN         FIND          LOGINV        RADIANS       TIMEVALUE
    CODE          FINV          LOGNORMDIST   RAND          TINV
    COLUMN        FISHER        LOOKUP        RANK          TODAY
    COLUMNS       FISHERINV     LOWER         RATE          TRANSPOSE
    COMBIN        FIXED         MATCH         REGISTER.ID   TREND
    CONCATENATE   FLOOR         MAX           REPLACE       TRIM
    CONFIDENCE    FORECAST      MDETERM       REPT          TRIMMEAN
    CORREL        FREQUENCY     MEDIAN        RIGHT         TRUE
    COS           FTEST         MID           ROMAN         TRUNC
    COSH          FV            MIN           ROUND         TTEST
    COUNT         GAMMADIST     MINUTE        ROUNDDOWN     TYPE
    COUNTA        GAMMAINV      MINVERSE      ROUNDUP       UPPER
    COUNTBLANK    GAMMALN       MIRR          ROW           VALUE
    COUNTIF       GEOMEAN       MMULT         ROWS          VAR
    COVAR         GROWTH        MOD           RSQ           VARP
    CRITBINOM     HARMEAN       MODE          SEARCH        VDB
    DATE          HLOOKUP       MONTH         SECOND        VLOOKUP
    DATEVALUE     HOUR          N             SIGN          WEEKDAY
    DAVERAGE      HYPGEOMDIST   NA            SIN           WEIBULL
    DAY           IF            NEGBINOMDIST  SINH          YEAR
    DAYS360       INDEX         NORMDIST      SKEW          ZTEST
</PRE>
</P>
<P>
You can also modify the module to support function names in the following
languages: German, French, Spanish, Portuguese, Dutch, Finnish, Italian and
Swedish. See the <CODE>function_locale.pl</CODE> program in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
For a general introduction to Excel's formulas and an explanation of the
syntax of the function refer to the Excel help files or the following: <A
HREF="http://office.microsoft.com/en-us/assistance/CH062528031033.aspx">http://office.microsoft.com/en-us/assistance/CH062528031033.aspx</A>


</P>
<P>
If your formula doesn't work in Spreadsheet::WriteExcel try the following:

</P>
<P>
<PRE>
    1. Verify that the formula works in Excel (or Gnumeric or OpenOffice.org).
    2. Ensure that it isn't on the Caveats list shown above.
    3. Ensure that cell references and formula names are in uppercase.
    4. Ensure that you are using ':' as the range operator, A1:A4.
    5. Ensure that you are using ',' as the union operator, SUM(1,2,3).
    6. Ensure that the function is in the above table.
</PRE>
</P>
<P>
If you go through steps 1-6 and you still have a problem, mail me.

</P>
<P>
<HR>
<H2><A NAME="Improving_performance_when_worki">Improving performance when working with formulas</A></H2>
<P>
Writing a large number of formulas with Spreadsheet::WriteExcel can be
slow. This is due to the fact that each formula has to be parsed and with
the current implementation this is computationally expensive.

</P>
<P>
However, in a lot of cases the formulas that you write will be quite
similar, for example:

</P>
<P>
<PRE>
    $worksheet-&gt;write_formula('B1',    '=A1 * 3 + 50',    $format);
    $worksheet-&gt;write_formula('B2',    '=A2 * 3 + 50',    $format);
    ...
    ...
    $worksheet-&gt;write_formula('B99',   '=A999 * 3 + 50',  $format);
    $worksheet-&gt;write_formula('B1000', '=A1000 * 3 + 50', $format);
</PRE>
</P>
<P>
In this example the cell reference changes in iterations from <CODE>A1</CODE> to <CODE>A1000</CODE>. The parser treats this variable as a <EM>token</EM> and arranges it according to predefined rules. However, since the parser is
oblivious to the value of the token, it is essentially performing the same
calculation 1000 times. This is inefficient.

</P>
<P>
The way to avoid this inefficiency and thereby speed up the writing of
formulas is to parse the formula once and then repeatedly substitute
similar tokens.

</P>
<P>
A formula can be parsed and stored via the <CODE>store_formula()</CODE> worksheet method. You can then use the <CODE>repeat_formula()</CODE> method to substitute <CODE>$pattern</CODE>, <CODE>$replace</CODE> pairs in the stored formula:

</P>
<P>
<PRE>
    my $formula = $worksheet-&gt;store_formula('=A1 * 3 + 50');
</PRE>
</P>
<P>
<PRE>
    for my $row (0..999) {
        $worksheet-&gt;repeat_formula($row, 1, $formula, $format, 'A1', 'A'.($row +1));
    }
</PRE>
</P>
<P>
On an arbitrary test machine this method was 10 times faster than the brute
force method shown above.

</P>
<P>
For more information about how Spreadsheet::WriteExcel parses and stores
formulas see the <CODE>Spreadsheet::WriteExcel::Formula</CODE> man page.

</P>
<P>
It should be noted however that the overall speed of direct formula parsing
will be improved in a future version.

</P>
<P>
<HR>
<H1><A NAME="EXAMPLES">EXAMPLES</A></H1>
<P>
<HR>
<H2><A NAME="Example_1">Example 1</A></H2>
<P>
The following example shows some of the basic features of
Spreadsheet::WriteExcel.

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    # Create a new workbook called simple.xls and add a worksheet
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('simple.xls');
    my $worksheet = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    # The general syntax is write($row, $column, $token). Note that row and
    # column are zero indexed
</PRE>
</P>
<P>
<PRE>
    # Write some text
    $worksheet-&gt;write(0, 0,  'Hi Excel!');
</PRE>
</P>
<P>
<PRE>
    # Write some numbers
    $worksheet-&gt;write(2, 0,  3);          # Writes 3
    $worksheet-&gt;write(3, 0,  3.00000);    # Writes 3
    $worksheet-&gt;write(4, 0,  3.00001);    # Writes 3.00001
    $worksheet-&gt;write(5, 0,  3.14159);    # TeX revision no.?
</PRE>
</P>
<P>
<PRE>
    # Write some formulas
    $worksheet-&gt;write(7, 0,  '=A3 + A6');
    $worksheet-&gt;write(8, 0,  '=IF(A5&gt;3,&quot;Yes&quot;, &quot;No&quot;)');
</PRE>
</P>
<P>
<PRE>
    # Write a hyperlink
    $worksheet-&gt;write(10, 0, '<A HREF="http://www.perl.com/">http://www.perl.com/</A>');
</PRE>
</P>

<br><center><img SRC="simple.gif" ALT="The output from simple.pl"></center>

<P>
<HR>
<H2><A NAME="Example_2">Example 2</A></H2>
<P>
The following is a general example which demonstrates some features of
working with multiple worksheets.

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    # Create a new Excel workbook
    my $workbook = Spreadsheet::WriteExcel-&gt;new('regions.xls');
</PRE>
</P>
<P>
<PRE>
    # Add some worksheets
    my $north = $workbook-&gt;add_worksheet('North');
    my $south = $workbook-&gt;add_worksheet('South');
    my $east  = $workbook-&gt;add_worksheet('East');
    my $west  = $workbook-&gt;add_worksheet('West');
</PRE>
</P>
<P>
<PRE>
    # Add a Format
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_bold();
    $format-&gt;set_color('blue');
</PRE>
</P>
<P>
<PRE>
    # Add a caption to each worksheet
    foreach my $worksheet ($workbook-&gt;sheets()) {
        $worksheet-&gt;write(0, 0, 'Sales', $format);
    }
</PRE>
</P>
<P>
<PRE>
    # Write some data
    $north-&gt;write(0, 1, 200000);
    $south-&gt;write(0, 1, 100000);
    $east-&gt;write (0, 1, 150000);
    $west-&gt;write (0, 1, 100000);
</PRE>
</P>
<P>
<PRE>
    # Set the active worksheet
    $south-&gt;activate();
</PRE>
</P>
<P>
<PRE>
    # Set the width of the first column
    $south-&gt;set_column(0, 0, 20);
</PRE>
</P>
<P>
<PRE>
    # Set the active cell
    $south-&gt;set_selection(0, 1);
</PRE>
</P>

<br><center><img SRC="regions.gif" ALT="The output from regions.pl"></center>

<P>
<HR>
<H2><A NAME="Example_3">Example 3</A></H2>
<P>
This example shows how to use a conditional numerical format with colours
to indicate if a share price has gone up or down.

</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    # Create a new workbook and add a worksheet
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('stocks.xls');
    my $worksheet = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    # Set the column width for columns 1, 2, 3 and 4
    $worksheet-&gt;set_column(0, 3, 15);
</PRE>
</P>
<P>
<PRE>
    # Create a format for the column headings
    my $header = $workbook-&gt;add_format();
    $header-&gt;set_bold();
    $header-&gt;set_size(12);
    $header-&gt;set_color('blue');
</PRE>
</P>
<P>
<PRE>
    # Create a format for the stock price
    my $f_price = $workbook-&gt;add_format();
    $f_price-&gt;set_align('left');
    $f_price-&gt;set_num_format('$0.00');
</PRE>
</P>
<P>
<PRE>
    # Create a format for the stock volume
    my $f_volume = $workbook-&gt;add_format();
    $f_volume-&gt;set_align('left');
    $f_volume-&gt;set_num_format('#,##0');
</PRE>
</P>
<P>
<PRE>
    # Create a format for the price change. This is an example of a
    # conditional format. The number is formatted as a percentage. If it is
    # positive it is formatted in green, if it is negative it is formatted
    # in red and if it is zero it is formatted as the default font colour
    # (in this case black). Note: the [Green] format produces an unappealing
    # lime green. Try [Color 10] instead for a dark green.
    #
    my $f_change = $workbook-&gt;add_format();
    $f_change-&gt;set_align('left');
    $f_change-&gt;set_num_format('[Green]0.0%;[Red]-0.0%;0.0%');
</PRE>
</P>
<P>
<PRE>
    # Write out the data
    $worksheet-&gt;write(0, 0, 'Company',$header);
    $worksheet-&gt;write(0, 1, 'Price',  $header);
    $worksheet-&gt;write(0, 2, 'Volume', $header);
    $worksheet-&gt;write(0, 3, 'Change', $header);
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(1, 0, 'Damage Inc.'       );
    $worksheet-&gt;write(1, 1, 30.25,    $f_price ); # $30.25
    $worksheet-&gt;write(1, 2, 1234567,  $f_volume); # 1,234,567
    $worksheet-&gt;write(1, 3, 0.085,    $f_change); # 8.5% in green
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(2, 0, 'Dump Corp.'        );
    $worksheet-&gt;write(2, 1, 1.56,     $f_price ); # $1.56
    $worksheet-&gt;write(2, 2, 7564,     $f_volume); # 7,564
    $worksheet-&gt;write(2, 3, -0.015,   $f_change); # -1.5% in red
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(3, 0, 'Rev Ltd.'          );
    $worksheet-&gt;write(3, 1, 0.13,     $f_price ); # $0.13
    $worksheet-&gt;write(3, 2, 321,      $f_volume); # 321
    $worksheet-&gt;write(3, 3, 0,        $f_change); # 0 in the font color (black)
</PRE>
</P>

<br><center><img SRC="stocks.gif" ALT="The output from stocks.pl"></center>

<P>
<HR>
<H2><A NAME="Example_4">Example 4</A></H2>
<P>
The following is a simple example of using functions.

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    # Create a new workbook and add a worksheet
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('stats.xls');
    my $worksheet = $workbook-&gt;add_worksheet('Test data');
</PRE>
</P>
<P>
<PRE>
    # Set the column width for columns 1
    $worksheet-&gt;set_column(0, 0, 20);
</PRE>
</P>
<P>
<PRE>
    # Create a format for the headings
    my $format = $workbook-&gt;add_format();
    $format-&gt;set_bold();
</PRE>
</P>
<P>
<PRE>
    # Write the sample data
    $worksheet-&gt;write(0, 0, 'Sample', $format);
    $worksheet-&gt;write(0, 1, 1);
    $worksheet-&gt;write(0, 2, 2);
    $worksheet-&gt;write(0, 3, 3);
    $worksheet-&gt;write(0, 4, 4);
    $worksheet-&gt;write(0, 5, 5);
    $worksheet-&gt;write(0, 6, 6);
    $worksheet-&gt;write(0, 7, 7);
    $worksheet-&gt;write(0, 8, 8);
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(1, 0, 'Length', $format);
    $worksheet-&gt;write(1, 1, 25.4);
    $worksheet-&gt;write(1, 2, 25.4);
    $worksheet-&gt;write(1, 3, 24.8);
    $worksheet-&gt;write(1, 4, 25.0);
    $worksheet-&gt;write(1, 5, 25.3);
    $worksheet-&gt;write(1, 6, 24.9);
    $worksheet-&gt;write(1, 7, 25.2);
    $worksheet-&gt;write(1, 8, 24.8);
</PRE>
</P>
<P>
<PRE>
    # Write some statistical functions
    $worksheet-&gt;write(4,  0, 'Count', $format);
    $worksheet-&gt;write(4,  1, '=COUNT(B1:I1)');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(5,  0, 'Sum', $format);
    $worksheet-&gt;write(5,  1, '=SUM(B2:I2)');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(6,  0, 'Average', $format);
    $worksheet-&gt;write(6,  1, '=AVERAGE(B2:I2)');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(7,  0, 'Min', $format);
    $worksheet-&gt;write(7,  1, '=MIN(B2:I2)');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(8,  0, 'Max', $format);
    $worksheet-&gt;write(8,  1, '=MAX(B2:I2)');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(9,  0, 'Standard Deviation', $format);
    $worksheet-&gt;write(9,  1, '=STDEV(B2:I2)');
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write(10, 0, 'Kurtosis', $format);
    $worksheet-&gt;write(10, 1, '=KURT(B2:I2)');
</PRE>
</P>

<br><center><img SRC="stats.gif" ALT="The output from stats.pl"></center>

<P>
<HR>
<H2><A NAME="Example_5">Example 5</A></H2>
<P>
The following example converts a tab separated file called <CODE>tab.txt</CODE> into an Excel file called <CODE>tab.xls</CODE>.

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>
    open (TABFILE, 'tab.txt') or die &quot;tab.txt: $!&quot;;
</PRE>
</P>
<P>
<PRE>
    my $workbook  = Spreadsheet::WriteExcel-&gt;new('tab.xls');
    my $worksheet = $workbook-&gt;add_worksheet();
</PRE>
</P>
<P>
<PRE>
    # Row and column are zero indexed
    my $row = 0;
</PRE>
</P>
<P>
<PRE>
    while (&lt;TABFILE&gt;) {
        chomp;
        # Split on single tab
        my @Fld = split('\t', $_);
</PRE>
</P>
<P>
<PRE>
        my $col = 0;
        foreach my $token (@Fld) {
            $worksheet-&gt;write($row, $col, $token);
            $col++;
        }
        $row++;
    }
</PRE>
</P>
<P>
NOTE: This is a simple conversion program for illustrative purposes only.
For converting a CSV or Tab separated or any other type of delimited text
file to Excel I recommend the more rigorous csv2xls program that is part of
H.Merijn Brand's Text::CSV_XS module distro.

</P>
<P>
See the examples/csv2xls link here: <A
HREF="http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST">http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST</A>


</P>
<P>
<HR>
<H2><A NAME="Additional_Examples">Additional Examples</A></H2>
<P>
If you performed a normal installation the following examples files should
have been copied to your <CODE>~site/Spreadsheet/WriteExcel/examples</CODE> directory:

</P>
<P>
The following is a description of the example files that are provided with
Spreadsheet::WriteExcel. They are intended to demonstrate the different
features and options of the module.

</P>
<P>
<PRE>
    Getting started
    ===============
    bug_report.pl           A template for submitting bug reports.
    a_simple.pl             An example of some of the basic features.
    demo.pl                 Creates a demo of some of the features.
    formats.pl              Creates a demo of the available formatting.
    regions.pl              Demonstrates multiple worksheets.
    stats.pl                Basic formulas and functions.
</PRE>
</P>
<P>
<PRE>
    Advanced
    ========
    autofilter.pl           Examples of worksheet autofilters.
    autofit.pl              Simulate Excel's autofit for column widths.
    bigfile.pl              Write past the 7MB limit with OLE::Storage_Lite.
    cgi.pl                  A simple CGI program.
    chess.pl                An example of formatting using properties.
    colors.pl               Demo of the colour palette and named colours.
    comments1.pl            Add comments to worksheet cells.
    comments2.pl            Add comments with advanced options.
    copyformat.pl           Example of copying a cell format.
    diag_border.pl          A simple example of diagonal cell borders.
    easter_egg.pl           Expose the Excel97 flight simulator. A must see.
    filehandle.pl           Examples of working with filehandles.
    formula_result.pl       Formulas with user specified results.
    headers.pl              Examples of worksheet headers and footers.
    hide_sheet.pl           Simple example of hiding a worksheet.
    hyperlink1.pl           Shows how to create web hyperlinks.
    hyperlink2.pl           Examples of internal and external hyperlinks.
    images.pl               Adding bitmap images to worksheets.
    indent.pl               An example of cell indentation.
    merge1.pl               A simple example of cell merging.
    merge2.pl               A simple example of cell merging with formatting.
    merge3.pl               Add hyperlinks to merged cells.
    merge4.pl               An advanced example of merging with formatting.
    merge5.pl               An advanced example of merging with formatting.
    merge6.pl               An example of merging with Unicode strings.
    mod_perl1.pl            A simple mod_perl 1 program.
    mod_perl2.pl            A simple mod_perl 2 program.
    outline.pl              An example of outlines and grouping.
    outline_collapsed.pl    Examples of collapsed outlines and grouping.
    panes.pl                An examples of how to create panes.
    protection.pl           Example of cell locking and formula hiding.
    repeat.pl               Example of writing repeated formulas.
    right_to_left.pl        Change default sheet direction to right to left.
    row_wrap.pl             How to wrap data from one worksheet onto another.
    sales.pl                An example of a simple sales spreadsheet.
    sendmail.pl             Send an Excel email attachment using Mail::Sender.
    stats_ext.pl            Same as stats.pl with external references.
    stocks.pl               Demonstrates conditional formatting.
    tab_colors.pl           Example of how to set worksheet tab colours.
    textwrap.pl             Demonstrates text wrapping options.
    win32ole.pl             A sample Win32::OLE example for comparison.
    write_arrays.pl         Example of writing 1D or 2D arrays of data.
    write_handler1.pl       Example of extending the write() method. Step 1.
    write_handler2.pl       Example of extending the write() method. Step 2.
    write_handler3.pl       Example of extending the write() method. Step 3.
    write_handler4.pl       Example of extending the write() method. Step 4.
    write_to_scalar.pl      Example of writing an Excel file to a Perl scalar.
</PRE>
</P>
<P>
<PRE>
    Unicode
    =======
    unicode_utf16.pl        Simple example of using Unicode UTF16 strings.
    unicode_utf16_japan.pl  Write Japanese Unicode strings using UTF-16.
    unicode_cyrillic.pl     Write Russian cyrillic strings using UTF-8.
    unicode_list.pl         List the chars in a Unicode font.
    unicode_2022_jp.pl      Japanese: ISO-2022-JP to utf8 in perl 5.8.
    unicode_8859_11.pl      Thai:     ISO-8859_11 to utf8 in perl 5.8.
    unicode_8859_7.pl       Greek:    ISO-8859_7  to utf8 in perl 5.8.
    unicode_big5.pl         Chinese:  BIG5        to utf8 in perl 5.8.
    unicode_cp1251.pl       Russian:  CP1251      to utf8 in perl 5.8.
    unicode_cp1256.pl       Arabic:   CP1256      to utf8 in perl 5.8.
    unicode_koi8r.pl        Russian:  KOI8-R      to utf8 in perl 5.8.
    unicode_polish_utf8.pl  Polish :  UTF8        to utf8 in perl 5.8.
    unicode_shift_jis.pl    Japanese: Shift JIS   to utf8 in perl 5.8.
</PRE>
</P>
<P>
<PRE>
    Utility
    =======
    csv2xls.pl              Program to convert a CSV file to an Excel file.
    datecalc1.pl            Convert Unix/Perl time to Excel time.
    datecalc2.pl            Calculate an Excel date using Date::Calc.
    lecxe.pl                Convert Excel to WriteExcel using Win32::OLE.
    tab2xls.pl              Program to convert a tab separated file to xls.
</PRE>
</P>
<P>
<PRE>
    Developer
    =========
    convertA1.pl            Helper functions for dealing with A1 notation.
    function_locale.pl      Add non-English function names to Formula.pm.
    writeA1.pl              Example of how to extend the module.
</PRE>
</P>
<P>
<HR>
<H1><A NAME="LIMITATIONS">LIMITATIONS</A></H1>
<P>
The following limits are imposed by Excel:

</P>
<P>
<PRE>
    Description                          Limit
    -----------------------------------  ------
    Maximum number of chars in a string  32767
    Maximum number of columns            256
    Maximum number of rows               65536
    Maximum chars in a sheet name        31
    Maximum chars in a header/footer     254
</PRE>
</P>
<P>
The minimum file size is 6K due to the OLE overhead. The maximum file size
is approximately 7MB (7087104 bytes) of BIFF data. This can be extended by
installing Takanori Kawai's OLE::Storage_Lite module <A
HREF="http://search.cpan.org/search?dist=OLE-Storage_Lite">http://search.cpan.org/search?dist=OLE-Storage_Lite</A>
see the <CODE>bigfile.pl</CODE> example in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
<HR>
<H1><A NAME="DOWNLOADING">DOWNLOADING</A></H1>
<P>
The latest version of this module is always available at: <A
HREF="http://search.cpan.org/search?dist=Spreadsheet-WriteExcel/">http://search.cpan.org/search?dist=Spreadsheet-WriteExcel/</A>


</P>
<P>
<HR>
<H1><A NAME="REQUIREMENTS">REQUIREMENTS</A></H1>
<P>
This module requires Perl >= 5.005, Parse::RecDescent, File::Temp and
OLE::Storage_Lite:

</P>
<P>
<PRE>
    <A HREF="http://search.cpan.org/search?dist=Parse-RecDescent/">http://search.cpan.org/search?dist=Parse-RecDescent/</A> # For formulas.
    <A HREF="http://search.cpan.org/search?dist=File-Temp/">http://search.cpan.org/search?dist=File-Temp/</A>        # For set_tempdir().
    <A HREF="http://search.cpan.org/search?dist=OLE-Storage_Lite/">http://search.cpan.org/search?dist=OLE-Storage_Lite/</A> # For files &gt; 7MB.
</PRE>
</P>
<P>
Note, these aren't strict requirements. Spreadsheet::WriteExcel will work
without these modules if you don't use <CODE>write_formula(),</CODE>
<CODE>set_tempdir()</CODE> or create files greater than 7MB. However, it is
best to install them if possible and they will be installed automatically
if you use a tool such as CPAN.pm or ppm.

</P>
<P>
<HR>
<H1><A NAME="INSTALLATION">INSTALLATION</A></H1>
<P>
See the INSTALL or install.html docs that come with the distribution or:

</P>
<P>
<A
HREF="http://search.cpan.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.21/INSTALL">http://search.cpan.org/src/JMCNAMARA/Spreadsheet-WriteExcel-2.21/INSTALL</A>


</P>
<P>
<HR>
<H1><A NAME="PORTABILITY">PORTABILITY</A></H1>
<P>
Spreadsheet::WriteExcel will work on the majority of Windows, UNIX and
Macintosh platforms. Specifically, the module will work on any system where
perl packs floats in the 64 bit IEEE format. The float must also be in
little-endian format but it will be reversed if necessary. Thus:

</P>
<P>
<PRE>
    print join(' ', map { sprintf '%#02x', $_ } unpack('C*', pack 'd', 1.2345)), &quot;\n&quot;;
</PRE>
</P>
<P>
should give (or in reverse order):

</P>
<P>
<PRE>
    0x8d 0x97 0x6e 0x12 0x83 0xc0 0xf3 0x3f
</PRE>
</P>
<P>
In general, if you don't know whether your system supports a 64 bit IEEE
float or not, it probably does. If your system doesn't, WriteExcel will <CODE>croak()</CODE> with the message given in the <A HREF="#DIAGNOSTICS">DIAGNOSTICS</A> section. You can check which platforms the module has been tested on at the
CPAN testers site: <A
HREF="http://testers.cpan.org/search?request=dist&dist=Spreadsheet-WriteExcel">http://testers.cpan.org/search?request=dist&dist=Spreadsheet-WriteExcel</A>


</P>
<P>
<HR>
<H1><A NAME="DIAGNOSTICS">DIAGNOSTICS</A></H1>
<DL>
<DT><A NAME="item_Filename">Filename required by Spreadsheet::WriteExcel-&gt;new()</A><DD>
<P>
A filename must be given in the constructor.

</P>
<DT><A NAME="item_Can">Can't open filename. It may be in use or protected.</A><DD>
<P>
The file cannot be opened for writing. The directory that you are writing
to may be protected or the file may be in use by another program.

</P>
<DT><A NAME="item_Unable">Unable to create tmp files via File::Temp::tempfile()...</A><DD>
<P>
This is a <CODE>-w</CODE> warning. You will see it if you are using Spreadsheet::WriteExcel in an
environment where temporary files cannot be created, in which case all data
will be stored in memory. The warning is for information only: it does not
affect creation but it will affect the speed of execution for large files.
See the <CODE>set_tempdir</CODE> workbook method.

</P>
<DT><A NAME="item_Maximum">Maximum file size, 7087104, exceeded.</A><DD>
<P>
The current OLE implementation only supports a maximum BIFF file of this
size. This limit can be extended, see the <A HREF="#LIMITATIONS">LIMITATIONS</A> section.

</P>
<DT>Can't locate Parse/RecDescent.pm in @INC ...<DD>
<P>
Spreadsheet::WriteExcel requires the Parse::RecDescent module. Download it
from CPAN: <A
HREF="http://search.cpan.org/search?dist=Parse-RecDescent">http://search.cpan.org/search?dist=Parse-RecDescent</A>


</P>
<DT><A NAME="item_Couldn">Couldn't parse formula ...</A><DD>
<P>
There are a large number of warnings which relate to badly formed formulas
and functions. See the <A HREF="#FORMULAS_AND_FUNCTIONS_IN_EXCEL">FORMULAS AND FUNCTIONS IN EXCEL</A> section for suggestions on how to avoid these errors. You should also check
the formula in Excel to ensure that it is valid.

</P>
<DT><A NAME="item_Required">Required floating point format not supported on this platform.</A><DD>
<P>
Operating system doesn't support 64 bit IEEE float or it is byte-ordered in
a way unknown to WriteExcel.

</P>
<DT><A NAME="item__file_xls_">'file.xls' cannot be accessed. The file may be read-only ...</A><DD>
<P>
You may sometimes encounter the following error when trying to open a file
in Excel: "file.xls cannot be accessed. The file may be read-only, or you
may be trying to access a read-only location. Or, the server the document
is stored on may not be responding."

</P>
<P>
This error generally means that the Excel file has been corrupted. There
are two likely causes of this: the file was FTPed in ASCII mode instead of
binary mode or else the file was created with <CODE>UTF-8</CODE> data returned by an XML parser. See <A HREF="#Warning_about_XML_Parser_and_pe">Warning about XML::Parser and perl 5.6</A> for further details.

</P>
</DL>
<P>
<HR>
<H1><A NAME="THE_EXCEL_BINARY_FORMAT">THE EXCEL BINARY FORMAT</A></H1>
<P>
The following is some general information about the Excel binary format for
anyone who may be interested.

</P>
<P>
Excel data is stored in the "Binary Interchange File Format" (BIFF) file
format. Details of this format are given in "Excel 97-2007 Binary File
Format Specification" <A
HREF="http://www.microsoft.com/interop/docs/OfficeBinaryFormats.mspx">http://www.microsoft.com/interop/docs/OfficeBinaryFormats.mspx</A>


</P>
<P>
Daniel Rentz of OpenOffice.org has also written a detailed description of
the Excel workbook records, see <A
HREF="http://sc.openoffice.org/excelfileformat.pdf">http://sc.openoffice.org/excelfileformat.pdf</A>


</P>
<P>
Charles Wybble has collected together additional information about the
Excel file format. See "The Chicago Project" at <A
HREF="http://chicago.sourceforge.net/devel/">http://chicago.sourceforge.net/devel/</A>


</P>
<P>
The BIFF data is stored along with other data in an OLE Compound File. This
is a structured storage which acts like a file system within a file. A
Compound File is comprised of storages and streams which, to follow the
file system analogy, are like directories and files.

</P>
<P>
The OLE format is explained in the "Windows Compound Binary File Format
Specification" <A
HREF="http://www.microsoft.com/interop/docs/supportingtechnologies.mspx">http://www.microsoft.com/interop/docs/supportingtechnologies.mspx</A>


</P>
<P>
The Digital Imaging Group have also detailed the OLE format in the JPEG2000
specification: see Appendix A of <A
HREF="http://www.i3a.org/pdf/wg1n1017.pdf">http://www.i3a.org/pdf/wg1n1017.pdf</A>


</P>
<P>
Please note that the provision of this information does not constitute an
invitation to start hacking at the BIFF or OLE file formats. There are more
interesting ways to waste your time. ;-)

</P>
<P>
<HR>
<H1><A NAME="WRITING_EXCEL_FILES">WRITING EXCEL FILES</A></H1>
<P>
Depending on your requirements, background and general sensibilities you
may prefer one of the following methods of getting data into Excel:

</P>
<UL>
<LI><A NAME="item_Win32">Win32::OLE module and office automation</A>
<P>
This requires a Windows platform and an installed copy of Excel. This is
the most powerful and complete method for interfacing with Excel. See <A
HREF="http://www.activestate.com/ASPN/Reference/Products/ActivePerl-5.6/faq/Windows/ActivePerl-Winfaq12.html">http://www.activestate.com/ASPN/Reference/Products/ActivePerl-5.6/faq/Windows/ActivePerl-Winfaq12.html</A>
and <A
HREF="http://www.activestate.com/ASPN/Reference/Products/ActivePerl-5.6/site/lib/Win32/OLE.html">http://www.activestate.com/ASPN/Reference/Products/ActivePerl-5.6/site/lib/Win32/OLE.html</A>
If your main platform is UNIX but you have the resources to set up a
separate Win32/MSOffice server, you can convert office documents to text,
postscript or PDF using Win32::OLE. For a demonstration of how to do this
using Perl see Docserver: <A
HREF="http://search.cpan.org/search?mode=module&query=docserver">http://search.cpan.org/search?mode=module&query=docserver</A>


</P>
<LI><A NAME="item_CSV">CSV, comma separated variables or text</A>
<P>
If the file extension is <CODE>csv</CODE>, Excel will open and convert this format automatically. Generating a valid
CSV file isn't as easy as it seems. Have a look at the DBD::RAM, DBD::CSV,
Text::xSV and Text::CSV_XS modules.

</P>
<LI><A NAME="item_DBI">DBI with DBD::ADO or DBD::ODBC</A>
<P>
Excel files contain an internal index table that allows them to act like a
database file. Using one of the standard Perl database modules you can
connect to an Excel file as a database.

</P>
<LI><A NAME="item_DBD">DBD::Excel</A>
<P>
You can also access Spreadsheet::WriteExcel using the standard DBI
interface via Takanori Kawai's DBD::Excel module <A
HREF="http://search.cpan.org/dist/DBD-Excel">http://search.cpan.org/dist/DBD-Excel</A>


</P>
<LI><A NAME="item_Spreadsheet">Spreadsheet::WriteExcelXML</A>
<P>
This module allows you to create an Excel XML file using the same interface
as Spreadsheet::WriteExcel. See: <A
HREF="http://search.cpan.org/dist/Spreadsheet-WriteExcelXML">http://search.cpan.org/dist/Spreadsheet-WriteExcelXML</A>


</P>
<LI><A NAME="item_Excel">Excel::Template</A>
<P>
This module allows you to create an Excel file from an XML template in a
manner similar to HTML::Template. See <A
HREF="http://search.cpan.org/dist/Excel-Template/">http://search.cpan.org/dist/Excel-Template/</A>


</P>
<LI><A NAME="item_Spreadsheet">Spreadsheet::WriteExcel::FromXML</A>
<P>
This module allows you to turn a simple XML file into an Excel file using
Spreadsheet::WriteExcel as a back-end. The format of the XML file is
defined by a supplied DTD: <A
HREF="http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromXML">http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromXML</A>


</P>
<LI><A NAME="item_Spreadsheet">Spreadsheet::WriteExcel::Simple</A>
<P>
This provides an easier interface to Spreadsheet::WriteExcel: <A
HREF="http://search.cpan.org/dist/Spreadsheet-WriteExcel-Simple">http://search.cpan.org/dist/Spreadsheet-WriteExcel-Simple</A>


</P>
<LI><A NAME="item_Spreadsheet">Spreadsheet::WriteExcel::FromDB</A>
<P>
This is a useful module for creating Excel files directly from a DB table:
<A
HREF="http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromDB">http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromDB</A>


</P>
<LI><A NAME="item_HTML">HTML tables</A>
<P>
This is an easy way of adding formatting via a text based format.

</P>
<LI><A NAME="item_XML">XML or HTML</A>
<P>
The Excel XML and HTML file specification are available from <A
HREF="http://msdn.microsoft.com/library/officedev/ofxml2k/ofxml2k.htm">http://msdn.microsoft.com/library/officedev/ofxml2k/ofxml2k.htm</A>


</P>
</UL>
<P>
For other Perl-Excel modules try the following search: <A
HREF="http://search.cpan.org/search?mode=module&query=excel">http://search.cpan.org/search?mode=module&query=excel</A>


</P>
<P>
<HR>
<H1><A NAME="READING_EXCEL_FILES">READING EXCEL FILES</A></H1>
<P>
To read data from Excel files try:

</P>
<UL>
<LI><A NAME="item_Spreadsheet">Spreadsheet::ParseExcel</A>
<P>
This uses the OLE::Storage-Lite module to extract data from an Excel file.
<A
HREF="http://search.cpan.org/dist/Spreadsheet-ParseExcel">http://search.cpan.org/dist/Spreadsheet-ParseExcel</A>


</P>
<LI><A NAME="item_Spreadsheet">Spreadsheet::ParseExcel_XLHTML</A>
<P>
This module uses Spreadsheet::ParseExcel's interface but uses xlHtml (see
below) to do the conversion: <A
HREF="http://search.cpan.org/dist/Spreadsheet-ParseExcel_XLHTML">http://search.cpan.org/dist/Spreadsheet-ParseExcel_XLHTML</A>
Spreadsheet::ParseExcel_XLHTML

</P>
<LI><A NAME="item_xlHtml">xlHtml</A>
<P>
This is an open source "Excel to HTML Converter" C/C++ project at <A
HREF="http://chicago.sourceforge.net/xlhtml/">http://chicago.sourceforge.net/xlhtml/</A>


</P>
<LI><A NAME="item_DBD">DBD::Excel (reading)</A>
<P>
You can also access Spreadsheet::ParseExcel using the standard DBI
interface via Takanori Kawai's DBD::Excel module <A
HREF="http://search.cpan.org/dist/DBD-Excel">http://search.cpan.org/dist/DBD-Excel</A>


</P>
<LI><A NAME="item_Win32">Win32::OLE module and office automation (reading)</A>
<P>
See, the section <A HREF="#WRITING_EXCEL_FILES">WRITING EXCEL FILES</A>.

</P>
<LI><A NAME="item_HTML">HTML tables (reading)</A>
<P>
If the files are saved from Excel in a HTML format the data can be accessed
using HTML::TableExtract <A
HREF="http://search.cpan.org/dist/HTML-TableExtract">http://search.cpan.org/dist/HTML-TableExtract</A>


</P>
<LI><A NAME="item_DBI">DBI with DBD::ADO or DBD::ODBC.</A>
<P>
See, the section <A HREF="#WRITING_EXCEL_FILES">WRITING EXCEL FILES</A>.

</P>
<LI><A NAME="item_XML">XML::Excel</A>
<P>
Converts Excel files to XML using Spreadsheet::ParseExcel <A
HREF="http://search.cpan.org/dist/XML-Excel.">http://search.cpan.org/dist/XML-Excel.</A>


</P>
<LI><A NAME="item_OLE">OLE::Storage, aka LAOLA</A>
<P>
This is a Perl interface to OLE file formats. In particular, the distro
contains an Excel to HTML converter called Herbert, <A
HREF="http://user.cs.tu-berlin.de/~schwartz/pmh/">http://user.cs.tu-berlin.de/~schwartz/pmh/</A>
This has been superseded by the Spreadsheet::ParseExcel module.

</P>
</UL>
<P>
For other Perl-Excel modules try the following search: <A
HREF="http://search.cpan.org/search?mode=module&query=excel">http://search.cpan.org/search?mode=module&query=excel</A>


</P>
<P>
If you wish to view Excel files on a UNIX/Linux platform check out the
excellent Gnumeric spreadsheet application at <A
HREF="http://www.gnome.org/projects/gnumeric/">http://www.gnome.org/projects/gnumeric/</A>
or OpenOffice.org at <A
HREF="http://www.openoffice.org/">http://www.openoffice.org/</A>

</P>
<P>
If you wish to view Excel files on a Windows platform which doesn't have
Excel installed you can use the free Microsoft Excel Viewer <A
HREF="http://office.microsoft.com/downloads/2000/xlviewer.aspx">http://office.microsoft.com/downloads/2000/xlviewer.aspx</A>


</P>
<P>
<HR>
<H1><A NAME="MODIFYING_AND_REWRITING_EXCEL_FI">MODIFYING AND REWRITING EXCEL FILES</A></H1>
<P>
An Excel file is a binary file within a binary file. It contains several
interlinked checksums and changing even one byte can cause it to become
corrupted.

</P>
<P>
As such you cannot simply append or update an Excel file. The only way to
achieve this is to read the entire file into memory, make the required
changes or additions and write the file out again.

</P>
<P>
You can read and rewrite an Excel file using the
Spreadsheet::ParseExcel::SaveParser module which is a wrapper around
Spreadsheet::ParseExcel and Spreadsheet::WriteExcel. It is part of the
Spreadsheet::ParseExcel package: <A
HREF="http://search.cpan.org/search?dist=Spreadsheet-ParseExcel">http://search.cpan.org/search?dist=Spreadsheet-ParseExcel</A>


</P>
<P>
However, you can only rewrite the features that Spreadsheet::WriteExcel
supports so macros, graphs and some other features in the original Excel
file will be lost. Also, formulas aren't rewritten, only the result of a
formula is written.

</P>
<P>
Here is an example:

</P>
<P>
<PRE>
    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>
    use strict;
    use Spreadsheet::ParseExcel;
    use Spreadsheet::ParseExcel::SaveParser;
</PRE>
</P>
<P>
<PRE>
    # Open the template with SaveParser
    my $parser   = new Spreadsheet::ParseExcel::SaveParser;
    my $template = $parser-&gt;Parse('template.xls');
</PRE>
</P>
<P>
<PRE>
    my $sheet    = 0;
    my $row      = 0;
    my $col      = 0;
</PRE>
</P>
<P>
<PRE>
    # Get the format from the cell
    my $format   = $template-&gt;{Worksheet}[$sheet]
                            -&gt;{Cells}[$row][$col]
                            -&gt;{FormatNo};
</PRE>
</P>
<P>
<PRE>
    # Write data to some cells
    $template-&gt;AddCell(0, $row,   $col,   1,     $format);
    $template-&gt;AddCell(0, $row+1, $col, &quot;Hello&quot;, $format);
</PRE>
</P>
<P>
<PRE>
    # Add a new worksheet
    $template-&gt;AddWorksheet('New Data');
</PRE>
</P>
<P>
<PRE>
    # The SaveParser SaveAs() method returns a reference to a
    # Spreadsheet::WriteExcel object. If you wish you can then
    # use this to access any of the methods that aren't
    # available from the SaveParser object. If you don't need
    # to do this just use SaveAs().
    #
    my $workbook;
</PRE>
</P>
<P>
<PRE>
    {
        # SaveAs generates a lot of harmless warnings about unset
        # Worksheet properties. You can ignore them if you wish.
        local $^W = 0;
</PRE>
</P>
<P>
<PRE>
        # Rewrite the file or save as a new file
        $workbook = $template-&gt;SaveAs('new.xls');
    }
</PRE>
</P>
<P>
<PRE>
    # Use Spreadsheet::WriteExcel methods
    my $worksheet  = $workbook-&gt;sheets(0);
</PRE>
</P>
<P>
<PRE>
    $worksheet-&gt;write($row+2, $col, &quot;World2&quot;);
</PRE>
</P>
<P>
<PRE>
    $workbook-&gt;close();
</PRE>
</P>
<P>
<HR>
<H1><A NAME="Warning_about_XML_Parser_and_pe">Warning about XML::Parser and perl 5.6</A></H1>
<P>
You must be careful when using Spreadsheet::WriteExcel in conjunction with
perl 5.6 and XML::Parser (and other XML parsers) due to the fact that the
data returned by the parser is generally in <CODE>UTF-8</CODE> format.

</P>
<P>
When <CODE>UTF-8</CODE> strings are added to Spreadsheet::WriteExcel's internal data it causes the
generated Excel file to become corrupt.

</P>
<P>
Note, this doesn't affect perl 5.005 (which doesn't try to handle <CODE>UTF-8</CODE>) or 5.8 (which handles it correctly).

</P>
<P>
To avoid this problem you should upgrade to perl 5.8, if possible, or else
you should convert the output data from XML::Parser to ASCII or ISO-8859-1
using one of the following methods:

</P>
<P>
<PRE>
    $new_str = pack 'C*', unpack 'U*', $utf8_str;
</PRE>
</P>
<P>
<PRE>
    use Unicode::MapUTF8 'from_utf8';
    $new_str = from_utf8({-str =&gt; $utf8_str, -charset =&gt; 'ISO-8859-1'});
</PRE>
</P>
<P>
<HR>
<H1><A NAME="Warning_about_Office_Service_Pac">Warning about Office Service Pack 3</A></H1>
<P>
If you have Office Service Pack 3 (SP3) installed you may see the following
warning when you open a file created by Spreadsheet::WriteExcel:

</P>
<P>
<PRE>
    &quot;File Error: data may have been lost&quot;.
</PRE>
</P>
<P>
This is usually caused by multiple instances of data in a cell.

</P>
<P>
SP3 changed Excel's default behaviour when it encounters multiple data in a
cell so that it issues a warning when the file is opened and it displays
the first data that was written. Prior to SP3 it didn't issue a warning and
displayed the last data written.

</P>
<P>
For a longer discussion and some workarounds see the following: <A
HREF="http://groups.google.com/group/spreadsheet-writeexcel/browse_thread/thread/3dcea40e6620af3a">http://groups.google.com/group/spreadsheet-writeexcel/browse_thread/thread/3dcea40e6620af3a</A>


</P>
<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
Formulas are formulae.

</P>
<P>
XML and <CODE>UTF-8</CODE> data on perl 5.6 can cause Excel files created by Spreadsheet::WriteExcel
to become corrupt. See <A HREF="#Warning_about_XML_Parser_and_pe">Warning about XML::Parser and perl 5.6</A> for further details.

</P>
<P>
The format object that is used with a <CODE>merge_range()</CODE> method call is marked internally as being associated with a merged range.It
is a fatal error to use a merged format in a non-merged cell. The current
workaround is to use separate formats for merged and non-merged cell. This
restriction will be removed in a future release.

</P>
<P>
Nested formulas sometimes aren't parsed correctly and give a result of
&quot;#VALUE&quot;. If you come across a formula that parses like this, let
me know.

</P>
<P>
Spreadsheet::ParseExcel: All formulas created by Spreadsheet::WriteExcel
are read as having a value of zero. This is because Spreadsheet::WriteExcel
only stores the formula and not the calculated result.

</P>
<P>
OpenOffice.org: No known issues in this release.

</P>
<P>
Gnumeric: No known issues in this release.

</P>
<P>
Excel 2008 for Mac: Hyperlinks generate a "File Error: data may have been
lost" warning.

</P>
<P>
If you wish to submit a bug report run the <CODE>bug_report.pl</CODE> program in the <CODE>examples</CODE> directory of the distro.

</P>
<P>
<HR>
<H1><A NAME="TO_DO">TO DO</A></H1>
<P>
The roadmap is as follows:

</P>
<UL>
<LI><A NAME="item_Add">Add named ranges.</A>
</UL>
<P>
Also, here are some of the most requested features that probably won't get
added:

</P>
<UL>
<LI><A NAME="item_Macros">Macros.</A>
<P>
This would solve some other problems neatly. However, the format of Excel
macros isn't documented.

</P>
<LI><A NAME="item_Some">Some feature that you really need. ;-)</A>
</UL>
<P>
If there is some feature of an Excel file that you really, really need then
you should use Win32::OLE with Excel on Windows. If you are on Unix you
could consider connecting to a Windows server via Docserver or SOAP, see <A HREF="#WRITING_EXCEL_FILES">WRITING EXCEL FILES</A>.

</P>
<P>
<HR>
<H1><A NAME="MAILING_LIST">MAILING LIST</A></H1>
<P>
There is a Google group for discussing and asking questions about
Spreadsheet::WriteExcel. This is a good place to search to see if your
question has been asked before: <A
HREF="http://groups-beta.google.com/group/spreadsheet-writeexcel/">http://groups-beta.google.com/group/spreadsheet-writeexcel/</A>
<p>
<table style="border:1px solid #aa0033; font-size:small" align=center>
  <tr>
    <td rowspan=3>
     <img src="http://groups-beta.google.com/groups/img/groups_medium.gif" height=58 width=150 alt="Google Groups">
    </td>
    <td colspan=2 align=center><b>Subscribe to Spreadsheet::WriteExcel</b></td>
  </tr>
  <form action="http://groups-beta.google.com/group/spreadsheet-writeexcel/boxsubscribe">
  <tr>
    <td>Email: <input type=text name=email></td>
    <td>
      <table
       style="background-color:#ffcc33;padding:2px;border:2px outset #ffcc33;">
      <tr>
        <td>
         <input type=submit name="sub" value="Subscribe">
        </td>
      </tr>
      </table>
    </td>
  </tr>
   </form>
  <tr><td colspan=2 align=center>
   <a href="http://groups-beta.google.com/group/spreadsheet-writeexcel">Browse Archives</a> at
    <a href="http://groups-beta.google.com/">groups-beta.google.com</a>
  </td></tr>
</table>


</P>
<P>
Alternatively you can keep up to date with future releases by subscribing
at: <A
HREF="http://freshmeat.net/projects/writeexcel/">http://freshmeat.net/projects/writeexcel/</A>


</P>
<P>
<HR>
<H1><A NAME="DONATIONS">DONATIONS</A></H1>
<P>
If you'd care to donate to the Spreadsheet::WriteExcel project, you can do
so via PayPal:

<center>
<form action="https://www.paypal.com/cgi-bin/webscr" method="post">
<input type="hidden" name="cmd" value="_xclick">
<input type="hidden" name="business" value="jmcnamara@cpan.org">
<input type="hidden" name="item_name" value="Spreadsheet::WriteExcel">
<input type="hidden" name="no_shipping" value="1">
<input type="hidden" name="cn" value="Optional note with donation">
<input type="hidden" name="currency_code" value="USD">
<input type="hidden" name="tax" value="0">
<input type="image" src="https://www.paypal.com/en_US/i/btn/x-click-but04.gif" border="0" name="submit" alt="Make payments with PayPal - it's fast, free and secure!">
</form>
</center>

</P>
<P>
<HR>
<H1><A NAME="SEE_ALSO">SEE ALSO</A></H1>
<P>
Spreadsheet::ParseExcel: <A
HREF="http://search.cpan.org/dist/Spreadsheet-ParseExcel">http://search.cpan.org/dist/Spreadsheet-ParseExcel</A>


</P>
<P>
Spreadsheet-WriteExcel-FromXML: <A
HREF="http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromXML">http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromXML</A>


</P>
<P>
Spreadsheet::WriteExcel::FromDB: <A
HREF="http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromDB">http://search.cpan.org/dist/Spreadsheet-WriteExcel-FromDB</A>


</P>
<P>
Excel::Template: <A
HREF="http://search.cpan.org/~rkinyon/Excel-Template/">http://search.cpan.org/~rkinyon/Excel-Template/</A>


</P>
<P>
DateTime::Format::Excel: <A
HREF="http://search.cpan.org/dist/DateTime-Format-Excel">http://search.cpan.org/dist/DateTime-Format-Excel</A>


</P>
<P>
"Reading and writing Excel files with Perl" by Teodor Zlatanov, at IBM
developerWorks: <A
HREF="http://www-106.ibm.com/developerworks/library/l-pexcel/">http://www-106.ibm.com/developerworks/library/l-pexcel/</A>


</P>
<P>
"Excel-Dateien mit Perl erstellen - Controller im Gluck" by Peter
Dintelmann and Christian Kirsch in the German Unix/web journal iX: <A
HREF="http://www.heise.de/ix/artikel/2001/06/175/">http://www.heise.de/ix/artikel/2001/06/175/</A>


</P>
<P>
Spreadsheet::WriteExcel documentation in Japanese by Takanori Kawai. <A
HREF="http://member.nifty.ne.jp/hippo2000/perltips/Spreadsheet/WriteExcel.htm">http://member.nifty.ne.jp/hippo2000/perltips/Spreadsheet/WriteExcel.htm</A>


</P>
<P>
Oesterly user brushes with fame: <A
HREF="http://oesterly.com/releases/12102000.html">http://oesterly.com/releases/12102000.html</A>


</P>
<P>
The csv2xls program that is part of Text::CSV_XS: <A
HREF="http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST">http://search.cpan.org/~hmbrand/Text-CSV_XS/MANIFEST</A>


</P>
<P>
<HR>
<H1><A NAME="ACKNOWLEDGMENTS">ACKNOWLEDGMENTS</A></H1>
<P>
The following people contributed to the debugging and testing of
Spreadsheet::WriteExcel:

</P>
<P>
Alexander Farber, Andre de Bruin, Arthur@ais, Artur Silveira da Cunha, Bob
Rose, Borgar Olsen, Brian Foley, Brian White, Bob Mackay, Cedric Bouvier,
Chad Johnson, CPAN testers, Damyan Ivanov, Daniel Berger, Daniel Gardner,
Dmitry Kochurov, Eric Frazier, Ernesto Baschny, Felipe Perez Galiana,
Gordon Simpson, Hanc Pavel, Harold Bamford, James Holmes, James Wilkinson,
Johan Ekenberg, Johann Hanne, Jonathan Scott Duff, J.C. Wren, Kenneth
Stacey, Keith Miller, Kyle Krom, Marc Rosenthal, Markus Schmitz, Michael
Braig, Michael Buschauer, Mike Blazer, Michael Erickson, Michael W J West,
Ning Xie, Paul J. Falbe, Paul Medynski, Peter Dintelmann, Pierre Laplante,
Praveen Kotha, Reto Badertscher, Rich Sorden, Shane Ashby, Sharron
McKenzie, Shenyu Zheng, Stephan Loescher, Steve Sapovits, Sven Passig,
Svetoslav Marinov, Tamas Gulacsi, Troy Daniels, Vahe Sarkissian.

</P>
<P>
The following people contributed patches, examples or Excel information:

</P>
<P>
Andrew Benham, Bill Young, Cedric Bouvier, Charles Wybble, Daniel Rentz,
David Robins, Franco Venturi, Guy Albertelli, Ian Penman, John Heitmann,
Jon Guy, Kyle R. Burton, Pierre-Jean Vouette, Rubio, Marco Geri, Mark
Fowler, Matisse Enzer, Sam Kington, Takanori Kawai, Tom O'Sullivan.

</P>
<P>
Many thanks to Ron McKelvey, Ronzo Consulting for Siemens, who sponsored
the development of the formula caching routines.

</P>
<P>
Many thanks to Cassens Transport who sponsored the development of the
embedded charts and autofilters.

</P>
<P>
Additional thanks to Takanori Kawai for translating the documentation into
Japanese.

</P>
<P>
Gunnar Wolf maintains the Debian distro.

</P>
<P>
Thanks to Damian Conway for the excellent Parse::RecDescent.

</P>
<P>
Thanks to Tim Jenness for File::Temp.

</P>
<P>
Thanks to Michael Meeks and Jody Goldberg for their work on Gnumeric.

</P>
<P>
<HR>
<H1><A NAME="DISCLAIMER_OF_WARRANTY">DISCLAIMER OF WARRANTY</A></H1>
<P>
Because this software is licensed free of charge, there is no warranty for
the software, to the extent permitted by applicable law. Except when
otherwise stated in writing the copyright holders and/or other parties
provide the software "as is" without warranty of any kind, either expressed
or implied, including, but not limited to, the implied warranties of
merchantability and fitness for a particular purpose. The entire risk as to
the quality and performance of the software is with you. Should the
software prove defective, you assume the cost of all necessary servicing,
repair, or correction.

</P>
<P>
In no event unless required by applicable law or agreed to in writing will
any copyright holder, or any other party who may modify and/or redistribute
the software as permitted by the above licence, be liable to you for
damages, including any general, special, incidental, or consequential
damages arising out of the use or inability to use the software (including
but not limited to loss of data or data being rendered inaccurate or losses
sustained by you or third parties or a failure of the software to operate
with any other software), even if such holder or other party has been
advised of the possibility of such damages.

</P>
<P>
<HR>
<H1><A NAME="LICENSE">LICENSE</A></H1>
<P>
Either the Perl Artistic Licence <A
HREF="http://dev.perl.org/licenses/artistic.html">http://dev.perl.org/licenses/artistic.html</A>
or the GPL <A
HREF="http://www.opensource.org/licenses/gpl-license.php">http://www.opensource.org/licenses/gpl-license.php</A>


</P>
<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
John McNamara <A HREF="mailto:jmcnamara@cpan.org">jmcnamara@cpan.org</A>

</P>
<P>
<PRE>
    Girl inform me
    All my senses warn me
    Your clever eyes could easily disguise
    Some backwards purpose
    It's enough to make me nervous.
    Do you harbor sighs, or spit in my eye
</PRE>
</P>
<P>
<PRE>
    But your lips when we speak
    Are the valleys and peaks of a mountain range on fire.
    So let me walk these coals till you believe
    I can cut the mustard well enough
    Cause you know as soon as breathe we scrutinize
</PRE>
</P>
<P>
<PRE>
        -- The Shins
</PRE>
</P>
<P>
<HR>
<H1><A NAME="COPYRIGHT">COPYRIGHT</A></H1>
<P>
Copyright MM-MMVIII, John McNamara.

</P>
<P>
All Rights Reserved. This module is free software. It may be used,
redistributed and/or modified under the same terms as Perl itself.

</P>

</BODY>

</HTML>
