<HTML>
<HEAD>
<TITLE>Spreadsheet::WriteExcel - Write text and numbers to a cross-platform Excel binary file.</TITLE>
<LINK REV="made" HREF="mailto:">
</HEAD>

<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A></LI>
	<LI><A HREF="#VERSION">VERSION</A></LI>
	<LI><A HREF="#SYNOPSIS">SYNOPSIS</A></LI>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A></LI>
	<LI><A HREF="#WORKBOOK_METHODS">WORKBOOK METHODS</A></LI>
	<UL>

		<LI><A HREF="#new_">new()</A></LI>
		<LI><A HREF="#addworksheet_sheetname_">addworksheet($sheetname)</A></LI>
		<LI><A HREF="#close_">close()</A></LI>
		<LI><A HREF="#worksheets_">worksheets()</A></LI>
	</UL>

	<LI><A HREF="#WORKSHEET_METHODS">WORKSHEET METHODS</A></LI>
	<UL>

		<LI><A HREF="#write_row_column_token_">write($row, $column, $token)</A></LI>
		<LI><A HREF="#write_number_row_column_num">write_number($row, $column, $number)</A></LI>
		<LI><A HREF="#write_string_row_column_str">write_string($row, $column, $string)</A></LI>
		<LI><A HREF="#activate_">activate()</A></LI>
		<LI><A HREF="#set_first_sheet_">set_first_sheet()</A></LI>
		<LI><A HREF="#set_selection_first_row_first">set_selection($first_row, $first_col, $last_row, $last_col);</A></LI>
		<LI><A HREF="#set_col_width_first_col_last_">set_col_width($first_col, $last_col, $width);</A></LI>
	</UL>

	<LI><A HREF="#EXAMPLES">EXAMPLES</A></LI>
	<LI><A HREF="#LIMITATIONS">LIMITATIONS</A></LI>
	<LI><A HREF="#PORTABILITY">PORTABILITY</A></LI>
	<LI><A HREF="#DIAGNOSTICS">DIAGNOSTICS</A></LI>
	<LI><A HREF="#THE_EXCEL_BINARY_FORMAT">THE EXCEL BINARY FORMAT</A></LI>
	<LI><A HREF="#WRITING_EXCEL_FILES">WRITING EXCEL FILES</A></LI>
	<LI><A HREF="#READING_EXCEL_FILES">READING EXCEL FILES</A></LI>
	<LI><A HREF="#BUGS">BUGS</A></LI>
	<LI><A HREF="#TO_DO">TO DO</A></LI>
	<LI><A HREF="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</A></LI>
	<LI><A HREF="#AUTHOR">AUTHOR</A></LI>
	<LI><A HREF="#COPYRIGHT">COPYRIGHT</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME</A></H1>
<P>
Spreadsheet::WriteExcel - Write text and numbers to a cross-platform Excel
binary file.

</P>
<P>
<HR>
<H1><A NAME="VERSION">VERSION</A></H1>
<P>
This document refers to version 0.21 of Spreadsheet::WriteExcel, released
October 1, 2000.

</P>
<P>
<HR>
<H1><A NAME="SYNOPSIS">SYNOPSIS</A></H1>
<P>
To write a string and a number to the first worksheet in an Excel workbook
called perl.xls:

</P>
<P>
<PRE>    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>    $row1 = $col1 = 0;
    $row2 = 1;
</PRE>
</P>
<P>
<PRE>    my $workbook = Spreadsheet::WriteExcel-&gt;new(&quot;perl.xls&quot;);
    $worksheet  = $workbook-&gt;addworksheet();
</PRE>
</P>
<P>
<PRE>    $worksheet-&gt;write($row1, $col1, &quot;Hi Excel!&quot;);
    $worksheet-&gt;write($row2, $col1, 1.2345);
</PRE>
</P>
<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION</A></H1>
<P>
The Spreadsheet::WriteExcel module can be used to write numbers and text in
the native Excel binary file format. Multiple worksheets can be added to a
workbook. Formatting of cells is not yet supported.

</P>
<P>
The Excel file produced by this module is compatible with Excel 5, 95, 97
and 2000.

</P>
<P>
The module will work on the majority of Windows, UNIX and Macintosh
platforms. Generated files are also compatible with the Linux/UNIX
spreadsheet applications Star Office, Gnumeric and XESS. The generated
files are not compatible with MS Access. 

</P>
<P>
<HR>
<H1><A NAME="WORKBOOK_METHODS">WORKBOOK METHODS</A></H1>
<P>
The Spreadsheet::WriteExcel module provides an object oriented interface to
a new Excel workbook.The following methods are available through a new
workbook.

</P>
<P>
<HR>
<H2><A NAME="new_">new()</A></H2>
<P>
A new Excel workbook is created using the <CODE>new()</CODE> constructor as follows:

</P>
<P>
<PRE>    my $workbook = Spreadsheet::WriteExcel-&gt;new(&quot;filename.xls&quot;);
</PRE>
</P>
<P>
Note <CODE>my</CODE> is required to allocate a new workbook regardless of whether the <CODE>strict</CODE> pragma is in operation or not.

</P>
<P>
You can redirect the output to STDOUT using the special Perl filehandle <CODE>&quot;-&quot;</CODE>. This can be useful for CGIs which have a Content-type of <CODE>application/vnd.ms-excel</CODE>, for example:

</P>
<P>
<PRE>    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>    use strict;
    use Spreadsheet::WriteExcel;
</PRE>
</P>
<P>
<PRE>    print &quot;Content-type: application/vnd.ms-excel\n\n&quot;;
</PRE>
</P>
<P>
<PRE>    my $workbook = Spreadsheet::WriteExcel-&gt;new(&quot;-&quot;);
    $workbook-&gt;write(0, 0, &quot;Hi Excel!&quot;);
</PRE>
</P>
<P>
<HR>
<H2><A NAME="addworksheet_sheetname_">addworksheet($sheetname)</A></H2>
<P>
At least one worksheet should be added to a new workbook:

</P>
<P>
<PRE>    $worksheet1 = $workbook-&gt;addworksheet();          # Sheet1
    $worksheet2 = $workbook-&gt;addworksheet('Foglio2'); # Foglio2
    $worksheet3 = $workbook-&gt;addworksheet('Data');    # Data
    $worksheet4 = $workbook-&gt;addworksheet();          # Sheet4
</PRE>
</P>
<P>
If <CODE>$sheetname</CODE> is not specified the default Excel convention will be followed, i.e.
Sheet1, Sheet2, etc.

</P>
<P>
<HR>
<H2><A NAME="close_">close()</A></H2>
<P>
The <CODE>close()</CODE> method can be called to explicitly close an Excel file. Otherwise the file
will be closed automatically when the object reference goes out of scope or
when the program ends.

</P>
<P>
<PRE>    $workbook-&gt;close();
</PRE>
</P>
<P>
In general it is only necessary to explicitly close a file if you want to
perform some other operation on it such as copying or checking the size.

</P>
<P>
<HR>
<H2><A NAME="worksheets_">worksheets()</A></H2>
<P>
The <CODE>worksheets()</CODE> method returns a reference to the array of worksheets in a workbook. This
can be useful if you want to repeat an operation on each worksheet in a
workbook or where you wish to refer to a worksheet by its index:

</P>
<P>
<PRE>    foreach $worksheet (@{$workbook-&gt;worksheets()}) {
       $worksheet-&gt;write(0, 0, &quot;Hello&quot;);
    }
    
    # or:
    
    $worksheets = $workbook-&gt;worksheets();
    @$worksheets[0]-&gt;write(0, 0, &quot;Hello&quot;);
</PRE>
</P>
<P>
References are explained in detail in <CODE>perlref</CODE> and <CODE>perlreftut</CODE> in the main Perl documentation.

</P>
<P>
<HR>
<H1><A NAME="WORKSHEET_METHODS">WORKSHEET METHODS</A></H1>
<P>
The following methods are available through to a new worksheet.

</P>
<P>
<HR>
<H2><A NAME="write_row_column_token_">write($row, $column, $token)</A></H2>
<P>
The  <CODE>write()</CODE> method calls <CODE>write_number()</CODE> if <CODE>$token</CODE> matches the following regex:

</P>
<P>
<PRE>    $token =~ /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/
</PRE>
</P>
<P>
Otherwise it calls <CODE>write_string()</CODE>:

</P>
<P>
<PRE>    $worksheet-&gt;write(0, 0, &quot;Hello&quot; );  # write_string()
    $worksheet-&gt;write(1, 0, &quot;One&quot;   );  # write_string()
    $worksheet-&gt;write(2, 0,  2      );  # write_number()
    $worksheet-&gt;write(3, 0,  3.00001);  # write_number()
</PRE>
</P>
<P>
It should be noted that <CODE>$row</CODE> and <CODE>$column</CODE> are zero indexed cell locations for the <CODE>write</CODE> methods. Thus, Cell A1 is (0, 0) and Cell AD2000 is (1999, 29). Cells can
be written to in any order. They can also be overwritten.

</P>
<P>
The <CODE>write</CODE> methods return:

</P>
<P>
<PRE>    0 for success
   -1 for insufficient number of arguments
   -2 for row or column out of bounds
   -3 for string too long.
</PRE>
</P>
<P>
<HR>
<H2><A NAME="write_number_row_column_num">write_number($row, $column, $number)</A></H2>
<P>
Write an integer or a float to the cell specified by <CODE>$row</CODE> and <CODE>$column</CODE>:

</P>
<P>
<PRE>    $worksheet-&gt;write_number(0, 0,  1     );
    $worksheet-&gt;write_number(1, 0,  2.3451);
</PRE>
</P>
<P>
<HR>
<H2><A NAME="write_string_row_column_str">write_string($row, $column, $string)</A></H2>
<P>
Write a string to the cell specified by <CODE>$row</CODE> and <CODE>$column</CODE>:

</P>
<P>
<PRE>    $worksheet-&gt;write_string(0, 0, &quot;Your text here&quot; );
</PRE>
</P>
<P>
The maximum string size is 255 characters.

</P>
<P>
<HR>
<H2><A NAME="activate_">activate()</A></H2>
<P>
The <CODE>activate()</CODE> method is used to specify which worksheet is initially selected in a
multi-sheet workbook:

</P>
<P>
<PRE>    $worksheet1 = $workbook-&gt;addworksheet('To');
    $worksheet2 = $workbook-&gt;addworksheet('the');
    $worksheet3 = $workbook-&gt;addworksheet('wind');
</PRE>
</P>
<P>
<PRE>    $worksheet3-&gt;activate();
</PRE>
</P>
<P>
This is similar to the Excel VBA activate method. The default value is the
first worksheet.

</P>
<P>
<HR>
<H2><A NAME="set_first_sheet_">set_first_sheet()</A></H2>
<P>
The <CODE>activate()</CODE> method determines which worksheet is initially selected. However, if there
are a large number of worksheets the selected worksheet may not appear on
the screen. To avoid this you can select which is the leftmost visible
worksheet using <CODE>set_first_sheet()</CODE>:

</P>
<P>
<PRE>    for (1..20) {
        $workbook-&gt;addworksheet;
    }
</PRE>
</P>
<P>
<PRE>    $worksheet21 = $workbook-&gt;addworksheet();
    $worksheet22 = $workbook-&gt;addworksheet();
</PRE>
</P>
<P>
<PRE>    $worksheet21-&gt;set_first_sheet();
    $worksheet22-&gt;activate();
</PRE>
</P>
<P>
This method is not required very often. The default value is the first
worksheet.

</P>
<P>
<HR>
<H2><A NAME="set_selection_first_row_first">set_selection($first_row, $first_col, $last_row, $last_col);</A></H2>
<P>
This method can be used to specify which cell or cells are selected in a
worksheet. The most common requirement is to select a single cell, in which
case <CODE>$last_row</CODE> and <CODE>$last_col</CODE> are not required. The active cell within a selected range is determined by
the order in which <CODE>$first</CODE> and <CODE>$last</CODE> are specified:

</P>
<P>
<PRE>    $worksheet1-&gt;set_selection(3, 3);
    $worksheet2-&gt;set_selection(3, 3, 6, 6);
    $worksheet3-&gt;set_selection(6, 6, 3, 3);
</PRE>
</P>
<P>
The default is cell (0, 0).

</P>
<P>
<HR>
<H2><A NAME="set_col_width_first_col_last_">set_col_width($first_col, $last_col, $width);</A></H2>
<P>
This method can be used to specify the width of a single column or a range
of columns. If the method is applied to a single column the value of <CODE>$first_col</CODE> and <CODE>$last_col</CODE> should be the same:

</P>
<P>
<PRE>    $worksheet-&gt;set_col_width(0, 0, 20);
    $worksheet-&gt;set_col_width(1, 3, 30);
</PRE>
</P>
<P>
The width corresponds to the column width value that is specified in Excel.
It is approximately equal to the length of a string in the default font of
Arial 10.

</P>
<P>
<HR>
<H1><A NAME="EXAMPLES">EXAMPLES</A></H1>
<P>
The following is a general example which demonstrates most of the features
of the Spreadsheet::WriteExcel module:

</P>
<P>
<PRE>    #!/usr/bin/perl -w
    
    use strict;
    use Spreadsheet::WriteExcel;
    
    # Create a new Excel workbook
    my $workbook = Spreadsheet::WriteExcel-&gt;new(&quot;regions.xls&quot;);
    
    # Add some worksheets
    my $north = $workbook-&gt;addworksheet(&quot;North&quot;);
    my $south = $workbook-&gt;addworksheet(&quot;South&quot;);
    my $east  = $workbook-&gt;addworksheet(&quot;East&quot;);
    my $west  = $workbook-&gt;addworksheet(&quot;West&quot;);
</PRE>
</P>
<P>
<PRE>    # Add a caption to each worksheet
    foreach my $worksheet (@{$workbook-&gt;worksheets()}) {
       $worksheet-&gt;write(0, 0, &quot;Sales&quot;);
    }
    
    # Write some data
    $north-&gt;write(0, 1, 200000);
    $south-&gt;write(0, 1, 100000);
    $east-&gt;write (0, 1, 150000);
    $west-&gt;write (0, 1, 100000);
    
    # Set the active worksheet
    $south-&gt;activate();
    
    # Set the width of the first column 
    $south-&gt;set_col_width(0, 0, 20);
    
    # Set the active cell
    $south-&gt;set_selection(0, 1);
</PRE>
</P>
<P>
The following example converts a tab separated file called <CODE>tab.txt</CODE> into an Excel file called <CODE>tab.xls</CODE>.

</P>
<P>
<PRE>    #!/usr/bin/perl -w
</PRE>
</P>
<P>
<PRE>    use strict;
    use Spreadsheet::WriteExcel;
    
    open (TABFILE, &quot;tab.txt&quot;) or die &quot;tab.txt: $!&quot;;
    
    my $workbook  = Spreadsheet::WriteExcel-&gt;new(&quot;tab.xls&quot;);
    my $worksheet = $workbook-&gt;addworksheet();
    
    # Row and column are zero indexed
    my $row = 0;
    
    while (&lt;TABFILE&gt;) {
        chomp;
        # Split on single tab
        my @Fld = split('\t', $_);
    
        my $col = 0;
        foreach my $token (@Fld) {
            $worksheet-&gt;write($row, $col, $token);
            $col++;
        }
        $row++;
    }
</PRE>
</P>
<P>
<HR>
<H1><A NAME="LIMITATIONS">LIMITATIONS</A></H1>
<P>
The following limits are imposed by Excel or the version of the BIFF file
that has been implemented:

</P>
<P>
<PRE>    Description                          Limit   Source
    -----------------------------------  ------  -------
    Maximum number of chars in a string  255     Excel 5
    Maximum number of columns            256     Excel 5, 97
    Maximum number of rows in Excel 5    16,384  Excel 5
    Maximum number of rows in Excel 97   65,536  Excel 97
</PRE>
</P>
<P>
The minimum file size is 6K due to the OLE overhead. The maximum file size
is approximately 7MB (7087104 bytes) of BIFF data.

</P>
<P>
<HR>
<H1><A NAME="PORTABILITY">PORTABILITY</A></H1>
<P>
WriteExcel.pm will only work on systems where perl packs floats in 64 bit
IEEE format. The float must also be in little-endian format but
WriteExcel.pm will reverse it as necessary. Thus:

</P>
<P>
<PRE>    print join(&quot; &quot;, map { sprintf &quot;%#02x&quot;, $_ } unpack(&quot;C*&quot;, pack &quot;d&quot;, 1.2345)), &quot;\n&quot;;
</PRE>
</P>
<P>
should give (or in reverse order):

</P>
<P>
<PRE>    0x8d 0x97 0x6e 0x12 0x83 0xc0 0xf3 0x3f
</PRE>
</P>
<P>
In general, if you don't know whether your system supports a 64 bit IEEE
float or not, it probably does. If your system doesn't WriteExcel will <CODE>croak()</CODE> with the message given in the Diagnostics section.

</P>
<P>
<HR>
<H1><A NAME="DIAGNOSTICS">DIAGNOSTICS</A></H1>
<DL>
<DT><STRONG><A NAME="item_Filename">Filename required in WriteExcel('Filename')</A></STRONG><DD>
<P>
A filename must be given in the constructor.

</P>
<DT><STRONG><A NAME="item_Can">Can't open filename. It may be in use.</A></STRONG><DD>
<P>
The file cannot be opened for writing. It may be protected or already in
use.

</P>
<DT><STRONG><A NAME="item_Required">Required floating point format not supported on this platform.</A></STRONG><DD>
<P>
Operating system doesn't support 64 bit IEEE float or it is byte-ordered in
a way unknown to WriteExcel.

</P>
<DT><STRONG><A NAME="item_Maximum">Maximum file size, 7087104, exceeded.</A></STRONG><DD>
<P>
The current OLE implementation only supports a maximum BIFF file of this
size.

</P>
</DL>
<P>
<HR>
<H1><A NAME="THE_EXCEL_BINARY_FORMAT">THE EXCEL BINARY FORMAT</A></H1>
<P>
Excel data is stored in the ``Binary Interchange File Format'' (BIFF) file
format. Details of this format are given in the Excel SDK, the ``Excel
Developer's Kit'' from Microsoft Press. It is also included in the MSDN CD
library but is no longer available on the MSDN website. An older version of
the BIFF documentation is available at <A
HREF="http://www.cubic.org/source/archive/fileform/misc/excel.txt">http://www.cubic.org/source/archive/fileform/misc/excel.txt</A>


</P>
<P>
Issues relating to the Excel SDK are discussed, occasionally, at <A
HREF="news://microsoft.public.excel.sdk">news://microsoft.public.excel.sdk</A>


</P>
<P>
The BIFF portion of the Excel file is comprised of contiguous binary
records that have different functions and that hold different types of
data. Each BIFF record is comprised of the following three parts:

</P>
<P>
<PRE>        Record name;   Hex identifier, length = 2 bytes
        Record length; Length of following data, length = 2 bytes
        Record data;   Data, length = variable
</PRE>
</P>
<P>
The BIFF data is stored along with other data in an OLE Compound File. This
is a structured storage which acts like a file system within a file. A
Compound File is comprised of storages and streams which, to follow the
file system analogy, are like directories and files.

</P>
<P>
The documentation for the OLE::Storage module, <A
HREF="http://user.cs.tu-berlin.de/~schwartz/pmh/guide.html">http://user.cs.tu-berlin.de/~schwartz/pmh/guide.html</A>
, contains one of the few descriptions of the OLE Compound File in the
public domain.

</P>
<P>
Another useful source is the filters project <A
HREF="http://arturo.directmail.org/filtersweb/">http://arturo.directmail.org/filtersweb/</A>
 

</P>
<P>
The source code for the Excel plugin of the Gnumeric spreadsheet also
contains information relevant to the Excel BIFF format and the OLE
container, <A HREF="http://www.gnumeric.org/">http://www.gnumeric.org/</A>

</P>
<P>
The soon to be GPLed source code for Star Office should also be of
interest, <A
HREF="http://www.openoffice.org/">http://www.openoffice.org/</A>

</P>
<P>
Please note that the provision of this information does not constitute an
invitation to start hacking at the BIFF or OLE file formats. There are more
interesting ways to waste your time. ;)

</P>
<P>
<HR>
<H1><A NAME="WRITING_EXCEL_FILES">WRITING EXCEL FILES</A></H1>
<P>
Depending on your requirements, background and general sensibilities you
may prefer one of the following methods of getting data into Excel:

</P>
<P>
* CSV, comma separated variables or text. If the file extension is <CODE>csv</CODE>, Excel will open and convert this format automatically.

</P>
<P>
* DBI, ADO or ODBC. Connect to an Excel file as a database. Using the
appropriate driver Excel will behave like a database.

</P>
<P>
* HTML tables. This is an easy way of adding formatting.

</P>
<P>
* Win32::OLE module and office automation. See, the section ``Reading Excel
Files''.

</P>
<P>
<HR>
<H1><A NAME="READING_EXCEL_FILES">READING EXCEL FILES</A></H1>
<P>
Despite the title of this module the most commonly asked questions are in
relation to reading Excel files. To read data from Excel files try:

</P>
<P>
* DBI, ADO or ODBC. Connect to an Excel file as a database. Using the
appropriate driver Excel will behave like a database.

</P>
<P>
* HTML tables. If the files are saved from Excel in a HTML format the data
can be accessed using HTML::TableExtract <A
HREF="http://search.cpan.org/search?dist=HTML-TableExtract">http://search.cpan.org/search?dist=HTML-TableExtract</A>


</P>
<P>
* OLE::Storage, aka LAOLA. This is a Perl interface to OLE file formats. In
particular, the distro contains an Excel to HTML converter called Herbert,
<A
HREF="http://user.cs.tu-berlin.de/~schwartz/pmh/">http://user.cs.tu-berlin.de/~schwartz/pmh/</A>
There is also an open source C/C++ project based on the LAOLA work. Try the
Filters Project at <A
HREF="http://arturo.directmail.org/filtersweb/">http://arturo.directmail.org/filtersweb/</A>
and the xlHtml Project at <A
HREF="http://www.xlhtml.org/">http://www.xlhtml.org/</A> The xlHtml filter
is more complete than Herbert.

</P>
<P>
* Win32::OLE module and office automation. This requires a Windows platform
and an installed copy of Excel. This is the most powerful and complete
method for interfacing with Excel. See <A
HREF="http://www.activestate.com/Products/ActivePerl/docs/faq/Windows/ActivePerl-Winfaq12.html">http://www.activestate.com/Products/ActivePerl/docs/faq/Windows/ActivePerl-Winfaq12.html</A>
and <A
HREF="http://www.activestate.com/Products/ActivePerl/docs/site/lib/Win32/OLE.html">http://www.activestate.com/Products/ActivePerl/docs/site/lib/Win32/OLE.html</A>


</P>
<P>
If your main platform is UNIX but you have the resources to set up a
separate Win32/MSOffice server, you can convert office documents to text,
postscript or PDF using Win32:OLE. For a demonstration of how to do this
using Perl see Docserver: <A
HREF="http://search.cpan.org/search?mode=module&query=docserver">http://search.cpan.org/search?mode=module&query=docserver</A>


</P>
<P>
If you wish to view Excel files on a UNIX/Linux platform check out the
excellent Gnumeric spreadsheet application at <A
HREF="http://www.gnumeric.org/gnumeric">http://www.gnumeric.org/gnumeric</A>


</P>
<P>
If you wish to view Excel files on Windows platforms which don't have Excel
installed you can use the free Microsoft Excel Viewer <A
HREF="http://officeupdate.microsoft.com/downloadDetails/xlviewer.htm">http://officeupdate.microsoft.com/downloadDetails/xlviewer.htm</A>


</P>
<P>
<HR>
<H1><A NAME="BUGS">BUGS</A></H1>
<P>
The Excel files that are produced by this module are not compatible with MS
Access. Use DBI or ODBC instead.

</P>
<P>
The lack of a portable way of writing a little-endian 64 bit IEEE float.

</P>
<P>
QuickView: If you wish to write files are fully compatible with QuickView
it is necessary to write the cells in a sequential row by row order.

</P>
<P>
<HR>
<H1><A NAME="TO_DO">TO DO</A></H1>
<P>
This module will be extended to include the following, probably in this
order:

</P>
<P>
<PRE>    1. Cell and font formatting
    2. Row and column formatting
    3. Unlimited file size
    4. Document summary information
    5. Formulas (maybe)
</PRE>
</P>
<P>
Items 1. and 2. should be ready be Nov 1 2000 unless you are reading this
in December 2000.

</P>
<P>
<HR>
<H1><A NAME="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</A></H1>
<P>
The following people contributed to the debugging and testing of
WriteExcel.pm:

</P>
<P>
Arthur@ais, Artur Silveira da Cunha, CPAN testers, Daniel Gardner, Harold
Bamford, Johan Ekenberg, John Wren, Michael Buschauer, Mike Blazer, Paul J.
Falbe.

</P>
<P>
<HR>
<H1><A NAME="AUTHOR">AUTHOR</A></H1>
<P>
John McNamara <A HREF="mailto:jmcnamara@cpan.org">jmcnamara@cpan.org</A>

</P>
<P>
<PRE>        I have eaten
        the plums
        that were in
        the icebox
</PRE>
</P>
<P>
<PRE>        and which
        you were probably
        saving
        for breakfast
</PRE>
</P>
<P>
<PRE>        Forgive me
        they were delicious
        so sweet
        and so cold
</PRE>
</P>
<P>
<PRE>        - William Carlos Williams
</PRE>
</P>
<P>
<HR>
<H1><A NAME="COPYRIGHT">COPYRIGHT</A></H1>
<P>
Copyright (c) 2000, John McNamara. All Rights Reserved. This module is free
software. It may be used, redistributed and/or modified under the same
terms as Perl itself.
</P>

</BODY>

</HTML>
